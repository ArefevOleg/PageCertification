<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="stylesheet" href="style.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
	<title>JS Documentation</title>
</head>
<body class="body">
<div class="container">
	<nav id="navbar">
		<header class="navTitle title"><span class="accent">JS</span> Documentation</header>
		<ul class="listItem">
			<li class="item"><a href="#Browser" class="nav-link">Работа в браузере</a>
      </li>
			<li class="item"><a href="#Variables" class="nav-link">Переменные</a></li>
			<li class="item item1"><a href="#Primitives" class="nav-link">Примитивные типы данных</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#String" class="nav-link">String</a></li>
          <li class="submenuItem"><a href="#Escape" class="nav-link">Escape-символы</a></li>
          <li class="submenuItem"><a href="#Number" class="nav-link">Number</a></li>
          <li class="submenuItem"><a href="#BigInt" class="nav-link">BigInt</a></li>
          <li class="submenuItem"><a href="#Boolean" class="nav-link">Boolean</a></li>
          <li class="submenuItem"><a href="#Symbol" class="nav-link">Symbol</a></li>
          <li class="submenuItem"><a href="#undefined" class="nav-link">undefined</a></li>
          <li class="submenuItem"><a href="#null" class="nav-link">null</a></li>
      </ul>
    </li>
			<li class="item"><a href="#Analysis" class="nav-link">Анализ и модификация типов данных</a></li>
			<li class="item"><a href="#Operators" class="nav-link">Операторы</a></li>
			<li class="item"><a href="#LogicalOperators" class="nav-link">Логические операторы</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#and" class="nav-link">«И» (&&)</a></li>
          <li class="submenuItem"><a href="#or" class="nav-link">«ИЛИ» (||)</a></li>
          <li class="submenuItem"><a href="#not" class="nav-link">«НЕ» (!)</a></li>
      </ul></li>
			<li class="item"><a href="#Array" class="nav-link">Массивы и их свойства</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#String" class="nav-link">Создание массивов</a></li>
          <li class="submenuItem"><a href="#Escape" class="nav-link">Доступ к элементам</a></li>
          <li class="submenuItem"><a href="#Number" class="nav-link">Перезапись элементов</a></li>
          <li class="submenuItem"><a href="#BigInt" class="nav-link">Встроенное свойство длины</a></li>
          <li class="submenuItem"><a href="#Boolean" class="nav-link">Методы</a></li>
          <li class="submenuItem"><a href="#Symbol" class="nav-link">Symbol</a></li>
          <li class="submenuItem"><a href="#undefined" class="nav-link">undefined</a></li>
          <li class="submenuItem"><a href="#null" class="nav-link">null</a></li>
      </ul></li>
			<li class="item"><a href="#Global_variables" class="nav-link">Global variables</a></li>
			<li class="item"><a href="#Constants" class="nav-link">Constants</a></li>
			<li class="item"><a href="#Data_types" class="nav-link">Data types</a></li>
			<li class="item"><a href="#if...else_statement" class="nav-link">if...else statement</a></li>
			<li class="item"><a href="#while_statement" class="nav-link">while statement</a></li>
			<li class="item"><a href="#Projects" class="nav-link">Проекты</a></li>
			<li class="item"><a href="#Mathematics" class="nav-link">Математика</a></li>
      <li class="item"><a href="#bottom" class="nav-link">Низ</a></li>
		</ul>
	</nav>
	<main id="main-doc" class="main">
		<section class="main-section" id="Browser">
			<header class="title">JavaScript работа в браузере</header>
			<p>JavaScript является интерпретируемым языком программирования: это значит,
         компьютер распознает его в процессе работы кода.
          Некоторые языки перед за- пуском кода требуют обработки 
          (данный процесс называется компиляцией) — но для JavaScript в этом нет необходимости. 
          Компьютер интерпретирует JavaScript на лету. При этом «движок», понимающий JavaScript, 
          называется интерпрета- тором.
        </p>
		</section>
		<section class="main-section" id="Variables">
			<header class="title">Переменные</header>
			<p>
				Определение переменной состоит из трех частей: определяющего слова <b class="codeText">let, var</b> или <b class="codeText">const</b>, 
        названия и значения.
        <b class="codeText"> let и var</b> используются для переменных, 
        которым где-то в программе может быть присвоено новое значение.
         Различия между let и var не так просты. Они связаны с областью их применения.
			</p>
			<ul>
				<li><b class="codeText">var</b>относится к глобальным переменным
          <p>Глобальность var означает, что вы можете использовать переменную, ранее опреде- ленную как var, в любом месте кода.</p>
				</li>
				<li>
					<b class="codeText">let</b> — локальная переменная
          <p> Область действия let ограничивается только конкретным блоком кода: вы можете использовать переменные, определенные с помо- щью let, только там, где они и были определены. </p>
				</li>
				<li>
					<b class="codeText">const</b>относится к глобальным переменным
          <p>
            Оператор const используется для переменных, которым присваивается значение только один раз,
             например π, которое априори не меняется. Если вы попытаетесь переназначить переменную const,
              система выдаст сообщение об ошибке</p>
              <code>
                const someConstant = 3;<br>
                someConstant = 4;</code>
                <code>Uncaught TypeError: Assignment to constant variable.</code>
				</li>
			</ul>
		</section>
		<section class="main-section" id="Primitives">
			<header class="title">Примитивы</header>
      <h3 id="String">String</h3>
			<p>
				Строковый тип данных используется для передачи текстовых значений. Это последовательность символов. Есть несколько способов объявить переменную строкового типа:
        <ul>
          <li>двойные кавычки;</li>
          <li>одинарные кавычки;</li>
          <li>обратные апострофы: специальные шаблонные строки, в которых вы можете напрямую использовать переменные.</li>
        </ul>
        <p>Так, например, следующее написание приведет к ошибке, потому что строка будет за- канчиваться апострофом внутри слова let's:</p>
        <code>let funActivity = 'Let's learn JavaScript';</code>
			</p>
      <p>Слово Let будет определено как строка, но после него набор символов не будет ин- терпретирован. Но если вы объявите строку, заключив ее в двойные кавычки, стро- ка не завершится, когда достигнет апострофа, потому что программа будет искать другую двойную кавычку. Следовательно, эта альтернатива будет работать лучше:</p>
      <code>let funActivity = "Let's learn JavaScript";</code>
      <p>Аналогичная история с двойными кавычками. Следующий код не будет работать:</p>
      <code>let question = "Do you want to learn JavaScript? "Yes!"";</code>
			<p>
				В строке, использующей обратные апострофы, вы можете ссылаться на перемен- ные — значение переменной будет подставлено в строку. Как во фрагменте кода, представленном ниже:
			</p>
      <code>let language = "JavaScript";<br>
        let message = `Let's learn ${language}`;<br>
        console.log(message);
        </code>
        <h3 id="Escape">Escape-символы</h3>
        <p>Допустим, мы хотим использовать в нашей строке двойные кавычки, одинарные кавычки и обратные апострофы. С теми ингредиентами, которые у нас есть сейчас, сделать подобное невозможно. Но для этой проблемы есть элегантное решение — специальный символ, с помощью которого можно сказать JavaScript: «Не читай следующий символ как обычно». Речь об escape-символе, обратном слеше.</p>
        <p>Обратный слеш может использоваться для того, чтобы интерпретатор не видел одинарные или двойные кавычки и не заканчивал строку слишком рано:</p>
        <code>
          let str = "Hello, what's your name? Is it \"Mike\"?";<br>
          console.log(str);<br>
          let str2 = 'Hello, what\'s your name? Is it "Mike"?';<br>
          console.log(str2);<br>
          В консоли выводится: <br>
 Hello, what's your name? Is it "Mike"?<br>
 Hello, what's your name? Is it "Mike"?<br>
          </code>
          <p>У escape-символа есть много назначений. Вы можете использовать его для созда- ния разрыва строки с помощью \n или для включения символа обратного слеша в текст с помощью \\:</p>
          <code>let str3 = "New \nline."; // перенос на новую строку<br> 
            let str4 = "I'm containing a backslash: \\!";<br>
            console.log(str3);<br>
            console.log(str4);<br>
            </code>
            <h3 id="Number">Number</h3>
            <p>Во многих языках существует очень четкая разница между различными типами чисел. Разработчики JavaScript решили использовать один тип данных для них всех: Number (если точнее, это 64-битное число с плавающей точкой). Этот тип может хранить довольно большие числа (как со знаком, так и без), десятичные дроби и многое другое.</p>
            <p>Существуют различные виды чисел, которые он может представлять. Прежде всего, целые числа, например 4 или 89. Но тип данных Number также может использовать- ся для представления десятичных, экспоненциальных, восьмеричных, шестнадца- теричных и двоичных чисел. Следующий пример кода говорит сам за себя:</p>
            <code>let intNr = 1;<br>
              let decNr = 1.5;<br>
              let expNr = 1.4e15;<br>
let octNr = 0o10; //в десятичной системе будет 8 <br>
let hexNr = 0x3E8; //в десятичной системе будет 1000 <br>
let binNr = 0b101; //в десятичной системе будет 5 <br>
            </code>
            <p>Не стоит переживать насчет последних трех позиций, если вы с ними не зна- комы, это просто разные способы представления чисел, с которыми вы можете столкнуться в более продвинутых задачах информационных технологий. Главное здесь то, что все вышеперечисленные числа относятся к типу данных Number. Итак, целые числа — это числа, подобные этим:</p>
            <code>
              let intNr2 = 3434;<br>
let intNr3 = -111;<br>
Числа с плавающей точкой тоже относятся к типу Number: <br>
let decNr2 = 45.78;<br>
И двоичные числа: <br>
let binNr2 = 0b100; // десятичная версия будет 4 <br>
            </code>
            <h3 id="BigInt">BigInt</h3>
            <p>Диапазон значений типа данных Number находится между 253–1 и –(253–1). BigInt вступает в дело, когда вам требуются числа больше (или меньше) этого интервала. Тип данных BigInt можно узнать по окончанию n:</p>
            <code>let bigNr = 90071992547409920n;</code>
            <p>Рассмотрим, что происходит, когда мы начинаем вычисления между ранее задан- ным целым числом типа Number, intNr, и значением типа BigInt, bigNr:</p>
            <code>let result = bigNr + intNr; <br>
              Результат будет таким: <br>
              Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions
            </code>
            <p>Ошибка типов данных — TypeError! Совершенно ясно: что-то пошло не так. Для выполнения операций нельзя смешивать тип данных BigInt с типом данных Number. Это то, что следует запомнить на будущее, когда вы будете работать с BigInt, — вы можете использовать BigInt только с другими BigInt.</p>
            <h3 id="Boolean">Boolean</h3>
            <p>Логический тип данных Boolean может принимать два значения: true (истина) и false (ложь). И ничего больше. Этот тип данных часто используется в коде, особенно в логических выражениях:</p>
            <code>
              let bool1 = false; <br>
              let bool2 = true;
            </code>
            <h3 id="Symbol">Symbol</h3>
            <p>Символьный тип Symbol совершенно новый и представлен в ES6 (мы упоминали стандарт ECMAScript 6 в главе 1 «Начало работы с JavaScript»). Он может уста- навливаться в случаях, когда важно подчеркнуть, что переменные не равны, даже если их значение и тип одинаковы (в этом случае они обе примут тип символа). Сравните следующие объявления строк с объявлениями символов (и те и другие имеют одинаковое значение):</p>
            <code>
              let str1 = "JavaScript is fun!";<br>
let str2 = "JavaScript is fun!";<br>
console.log("These two strings are the same:", str1 === str2);<br>
let sym1 = Symbol("JavaScript is fun!");<br>
let sym2 = Symbol("JavaScript is fun!");<br>
console.log("These two Symbols are the same:", sym1 === sym2);<br>
Результат будет следующим:<br>
 These two strings are the same: true<br>
 These two Symbols are the same: false<br>
            </code>
            <p>В первой части кода JavaScript приходит к выводу, что строки одинаковые, 
              у них один тип и значение. Однако во второй части кода каждый символ определяется как уникальный. Поэтому,
               хотя содержимое символов одинаковое, они не совпадают и при сравнении выводится значение false.
                <span class="codeText">Эти символьные типы данных могут быть очень удобны в качестве свойств объектов</span>, которые мы рассмотрим в <span class="codeText">главе 3</span>.</p>
        <h3 id="undefined">undefined</h3>
        <code>
          let unassigned; <br>
console.log(unassigned); <br>
Результат будет таким: Undefined
        </code>
        <p>Мы также можем целенаправленно назначать undefined — важно знать, что такое возможно. Но еще важнее знать, что <span class="codeText">присвоение типа undefined вручную — плохая практика:</span></p>
        <p>Да, так можно, но лучше так не делайте. По целому ряду причин — например,<span class="codeText"> в слу- чаях, когда требуется проверить, совпадают ли две переменные</span>. Если одна пере- менная не определена (undefined), а вашей собственной переменной вы вручную присвоили значение undefined,
           переменные будут считаться равными. Но вы же хотите знать, действительно ли значения равны, а не только то, что они не определе- ны. Так, кличка чьего-то домашнего животного и фамилия хозяина могут считаться равными, тогда как на самом деле они являются просто пустыми значениями.</p>
<h3 id="null">null</h3>
<p>null — это специальное значение, указывающее на то, что переменная пуста или имеет неизвестное значение. Данное значение чувствительно к регистру — для написания null используются только строчные буквы:
</p>
<code>let empty = null;</code>
<p>
  Чтобы решить проблему, с которой мы столкнулись при объявлении переменной как неопределенной, следует установить для нее значение null — и проблем не воз- никнет. Это одна из причин, по которой лучше присваивать переменной значение null, если вы хотите указать, что она изначально пуста и неизвестна:</p>
  <code>
    let terribleThingToDo = undefined; <br>
let lastName;<br>
console.log("Same undefined:", lastName === terribleThingToDo);<br>
let betterOption = null;<br>
console.log("Same null:", lastName === betterOption);<br>
Результат будет следующим:<br>
 Same undefined: true<br>
 Same null: false<br>
  </code>
  <p>Как видим, автоматически не определенная переменная, lastName, и намеренно не определенная переменная, terribleThingToDo, считаются равными — это про- блематично. С другой стороны, lastName и betterOption, которой было присвоено значение null, не равны.</p>
		</section>
		<section class="main-section" id="Analysis">
      <header class="title">Анализ и модификация типов данных</header>
      <p>Мы рассмотрели примитивные типы данных. Существует несколько встроенных методов JavaScript, которые помогут справиться с распространенными проблемами, возникающими при работе с примитивами. Встроенные методы — это части логи- ческой схемы, которые можно использовать сразу и не мучиться над их созданием вручную.</p>
<h3>Определение типа переменной</h3>
<p>Иногда трудно определить тип данных, с которым вы имеете дело, особенно в слу- чае null и undefined. Рассмотрим оператор typeof. Он возвращает тип переменной. С его помощью вы можете получить эту информацию. Введите typeof, затем либо пробел, за которым следует рассматриваемая переменная, либо эту переменную в скобках:</p>
<code>testVariable = 1;<br>
  variableTypeTest1 = typeof testVariable;<br>
  variableTypeTest2 = typeof(testVariable);<br>
  console.log(variableTypeTest1);<br>
  console.log(variableTypeTest2);<br>
</code>
<p>Как вы могли предположить, оба метода выведут number. Скобки не требуются, потому что технически typeof является оператором, а не методом, в отличие от console.log. Хотя на практике вы наверняка заметите, что использование скобок облегчает чтение вашего кода. Рассмотрим следующий пример:</p>
<code>
  let str = "Hello"; <br>
let nr = 7;<br>
let bigNr = 12345678901234n;<br>
let bool = true;<br>
let sym = Symbol("unique");<br>
let undef = undefined;<br>
let unknown = null;<br>
console.log("str", typeof str); str string<br>
console.log("nr", typeof nr); nr number<br>
console.log("bigNr", typeof bigNr); bigNr bigint<br>
console.log("bool", typeof bool); bool boolean<br>
console.log("sym", typeof sym); sym symbol<br>
console.log("undef", typeof undef); undef undefined<br>
console.log("unknown", typeof unknown); unknown object<br>
</code>
<p>Последний тип — это и есть тип null. 
  В выводе можно наблюдать, что typeof null возвращает значение object,
   в то время как <span class="codeText">на самом деле null является примити- вом, а не объектом</span>. 
   Это ошибка, которая существует в JavaScript с незапамятных времен и которую пока нет возможности исправить из-за проблем с обратной со- вместимостью. Не беспокойтесь о ней: на выполнение программ она не повлияет, но имейте эту ошибку в виду, поскольку в ближайшее время она никуда не денется и может повлиять на адекватную работу приложений.</p>
   <h3>Преобразование типов данных</h3>
   <p>В JavaScript можно изменить тип данных переменных. Иногда JavaScript делает это автоматически.</p>
   <code>
    let nr1 = 2;<br>
let nr2 = "2";<br>
console.log(nr1 * nr2);<br>
   </code>
   <p>Мы попытались умножить переменную типа Number на переменную типа String. 
    JavaScript не выдает ошибку (как сделали бы многие другие языки), 
    а пытается сна- чала преобразовать значение переменной String в Number. Если это можно сделать, команда выполняется без каких-либо проблем, как если бы были объявлены две пере- менные типа Number. В таком случае метод console.log() выдает результат 4 на экране.</p>
    <p>Но это достаточно опасный ход!</p>
    <code>let nr1 = 2;<br>
      let nr2 = "2";<br>
      console.log(nr1 + nr2); // 22 typeof = string<br>
    </code>
    <p>Результатом будет 22. Знак плюс можно использовать для объединения строк.
       Поэтому вместо преобразования string в number код <span class="codeText">преобразует number в string.</span>
        И соединяет две строки — 2 и 2, выдавая в результате строку 22.
         К счастью, нам не нужно полагаться на поведение JavaScript при преобразовании типов данных.
          Существуют встроенные функции, которые мы можем для этого использовать.</p>
<h3>Три метода преобразования: String(), Number() и Boolean()</h3>
<p>
  Рассмотрим три метода преобразования: <span class="codeText">String()</span>, Number() и Boolean().
   Первый преобразует переменную в тип String. Он, в общем-то, <span class="codeText">принимает любое значение, включая undefined и null, и заключает его в кавычки.</span></p>
<p>Второй <span class="codeText">Number()</span> пытается преобразовать переменную в тип Number. Если это невозможно сделать логически, значением переменной станет NaN (not a number — «не число»).</p>
<p><span class="codeText">Boolean()</span> преобразует переменную в тип Boolean. Данный метод <span class="codeText">будет работать для всего, кроме null, undefined, 0 (число), пустой строки и NaN.</span> Посмотрим на эти методы в действии:</p>
<code>
  let nrToStr = 6;<br>
nrToStr = String(nrToStr);<br>
console.log(nrToStr, typeof nrToStr); // 6 string<br>
let strToNr = "12";<br>
strToNr = Number(strToNr);<br>
console.log(strToNr, typeof strToNr); // 12 number<br>
let strToBool = "any string will return true";<br>
strToBool = Boolean(strToBool);<br>
console.log(strToBool, typeof strToBool); // true boolean<br>
</code>
<p>Выглядит довольно просто, но не все так очевидно. Например, вы все еще можете
  получить не то, на что рассчитывали:</p>
  <code>
    let nullToNr = null;<br>
nullToNr = Number(nullToNr);<br>
console.log("null", nullToNr, typeof nullToNr); //  null 0 number<br>
let strToNr = "";<br>
strToNr = Number(strToNr);<br>
console.log("empty string", strToNr, typeof strToNr); // empty string 0 number<br>
  </code>
  <p>Как видим, <span class="codeText">пустая строка и null в итоге дают 0</span>. Это выбор, сделанный создателями JavaScript, о котором вам нужно знать — данная опция может пригодиться в тех случаях, 
    когда вы захотите преобразовать строку в 0, в то время как она пуста или равна нулю.</p>
    <code>
      Далее введем фрагмент:<br>
let strToNr2 = "hello";<br>
strToNr2 = Number(strToNr2);<br>
console.log(strToNr2, typeof strToNr2); // NaN number<br>
    </code>
    <p>Следовательно, все, что нельзя интерпретировать как число, просто удалив кавыч- ки, будет оцениваться как NaN (не число).
    </p>
    <code>Продолжим таким кодом:<br>
      let strToBool2 = "false";<br>
      strToBool2 = Boolean(strToBool2);<br>
      console.log(strToBool2, typeof strToBool2); // true boolean<br>
      let strToBool = "";<br>
      strToBool = Boolean(strToBool);<br>
      console.log(strToBool, typeof strToBool); // false boolean<br>
    </code>
    <p>Этот пример показывает, что практически любая строка возвращает значение true, 
      когда преобразуется в тип Boolean, даже строка со значением false! Только пустая строка, null и undefined отправят логическое значение false.</p>
<code>
  let nr1 = 2;<br>
let nr2 = "2";<br>
console.log(nr1 + Number(nr2)); // 4<br>
</code>
<p>Строка преобразуется в число до выполнения опера- ции «плюс» — соответственно, это математическая операция, а не объединение строк. В следующих разделах данной главы мы рассмотрим операторы более подробно.</p>

    </section>
    <section class="main-section" id="Operators">
      <header class="title">Операторы</header>
      <p>Операторы будут полезны всякий раз, когда мы захотим работать с переменными, изменять их, выполнять над ними вычисления и сравнивать. Они называются операторами, потому что мы используем их, чтобы оперировать переменными.</p>
<h3>Арифметические операторы</h3>
<h3>Сложение</h3>
<p>Этот оператор также может быть очень полезен для объединения строк. Обратите внимание на пробел после Hello — он нужен в конечном результате:</p>
<code>
  let str1 = "Hello ";<br>
  let str2 = "addition";<br>
  let result2 = str1 + str2; // Hello addition<br>
  let nr1 = 12;<br>
let nr2 = 14;<br>
let result1 = nr1 + nr2; // 26<br>
<p>Если мы сложим две разные строки, это объединит их в одну строку.</p>
</code>
<h3>Вычитание</h3>
<p>Вычитание также работает ожидаемым образом. Для этого действия используется оператор -.</p>
<code>
  let nr1 = 20;<br>
let nr2 = 4;<br>
let str1 = "Hi";<br>

let nr3 = 3;<br>
let result1 = nr1 - nr2;<br>
let result2 = str1 - nr3;<br>
console.log(result1, result2); // 16 NaN<br>
</code>
<p>Первый результат — число 16. А второй результат намного более интересен.
  <span class="codeText"> NaN не ошибка: это просто заключение, что результат вычитания числа из строки не является числом</span>. Спасибо, что не падаешь, JavaScript!</p>
<h3>Умножение</h3>
<p>Мы можем умножать два числовых значения с помощью оператора *. В отличие от некоторых других языков в JavaScript данное действие не получится совершить с числом и строкой.</p>
<p>Результатом умножения числового и нечислового значений является NaN:</p>
<code>
  let nr1 = 15;<br>
let nr2 = 10;<br>
let str1 = "Hi";<br>
let nr3 = 3;<br>
let result1 = nr1 * nr2;<br>
let result2 = str1 * nr3;<br>
console.log(result1, result2); // 150 NaN<br>
</code>
<h3>Деление</h3>
<p>Еще один простой оператор — это деление. Мы можем разделить одно число на другое, используя оператор /:</p>
<code>
  let nr1 = 30;<br>
let nr2 = 5;<br>
let result1 = nr1 / nr2;<br>
console.log(result1); // 6<br>
</code>
<h3>Возведение в степень</h3>
<p>Возведение в степень означает возведение определенного базового числа в степень экспоненты, например xy (произносится как «возведение x в степень y»). Это зна- чит, что x будет умножено само на себя y раз. Чтобы возвести число в степень в JavaScript, используем ** для вызова оператора:</p>
<code>
  let nr1 = 2;<br>
let nr2 = 3;<br>
let result1 = nr1 ** nr2;<br>
console.log(result1); // 8<br>
</code>
<p>Результат этой операции равен 2 в степени 3 (2 × 2 × 2), что составляет 8. Чтобы не превращать книгу в урок математики, добавим только, что, используя дробные показатели, с помощью этой же операции мы можем найти корень числа: например, квадратный корень из значения — это то же самое, что возведение его в степень 0,5.</p>
<h3>Оператор деления по модулю %</h3>
<p>Данный оператор обычно требует пояснений. <span class="codeText">Модуль — это операция, определя- ющая остаток после полного деления одного числа на другое. Количество раз, которое одно число может поместиться в другое</span>, здесь не имеет значения — <span class="red">результатом будет остаток</span>. Для вызова оператора используется символ %. Вот несколько примеров:
</p>
<code>
  let nr1 = 10;<br>
let nr2 = 3;<br>
let result1 = nr1 % nr2;<br>
console.log(`${nr1} % ${nr2} = ${result1}`); // 10 % 3 = 1<br>
let nr3 = 8;<br>
let nr4 = 2;<br>
let result2 = nr3 % nr4;<br>
console.log(`${nr3} % ${nr4} = ${result2}`); // 8 % 2 = 0<br>
let nr5 = 15;<br>
let nr6 = 4;<br>
let result3 = nr5 % nr6;<br>
console.log(`${nr5} % ${nr6} = ${result3}`); 15 % 4 = 3<br>
</code>
<p>Первый пример — 10 % 3, где 3 умещается 3 раза в числе 10 с остатком 1. Вто- рой — 8 % 2. Здесь результат 0, потому что 2 повторяется 4 раза в числе 8 и ничего не остается. Последний — 15 % 4, где 4 умещается 3 раза в числе 15, после чего получается остаток 3.</p>
<p>По сути, это те действия, которые вы бы совершили у себя в голове, если бы вас попросили добавить 125 минут к текущему времени. Вероятно, вы бы сделали две вещи: целочисленное деление, чтобы определить, сколько целых часов содержится в 125 минутах, а затем 125 модуль 60 (в терминах JavaScript, 125 % 60), чтобы сде- лать вывод, что вам придется добавить еще 5 минут. Скажем, наше текущее время 09:59. Скорее всего, вы начнете с добавления 2 часов и дойдете до 11:59, а затем добавите 5 минут, выполнив еще одну операцию по модулю с 59 и 5, добавив еще 1 час к общей сумме и оставив 4 минуты: 12:04.
</p>
<h3>Унарные операторы: инкремент и декремент</h3>
<p>Инкремент и декремент. Здесь нам пригодится термин «операнд». Операнд — то, к чему применяется оператор. Если мы пишем x + y, то x и y — это операнды.</p>
<p>Для данных операторов потребуется только один операнд — поэтому они также называются унарными операторами. Если перед нами x++, то эту запись можно представить в виде x = x + 1. То же самое справедливо для оператора декремента: x-- принимает вид x = x – 1:</p>
<code>
let nr1 = 4;<br>
nr1++;<br>
console.log(nr1); // 5<br>
let nr2 = 4;<br>
nr2--;<br>
console.log(nr2); // 3<br>
</code>
<h3>Операторы prefix и postfix</h3>
  <p>Инкремент может располагаться после операнда (x++), в таком случае он будет на- зываться постфиксным унарным оператором. Он также может располагаться до операнда (++x) — префиксный унарный оператор. Однако он выполняет кое-что
    другое.
  </p>
  <p>Сначала отправляется переменная, потом выполняется постфикс и только после этого — операция. В следующем примере nr повышается на 1 после логирования. Поэтому в первый раз переменная логируется без изменений, потому что обнов- ление еще не произошло. Обновление произойдет во второй раз:</p>
<code>
  let nr = 2;<br>
console.log(nr++); // 2<br>
console.log(nr); // 3<br>
</code>
<p>Префикс выполняется перед отправкой переменной, поэтому чаще всего исполь- зуется именно он.
</p>
<code>
  let nr = 2;<br>
console.log(++nr); // 3<br>
</code>
<p></p>
<code>
  let nr1 = 4;<br>
let nr2 = 5;<br>
let nr3 = 2;<br>
console.log(nr1++ + ++nr2 * nr3++); // ( ++nr2 * nr3++) + nr1++ = 16<br>
</code>
<p>Результат будет равен 16. Сначала будет выполнено умножение в соответствии с основным математическим порядком операций. Для умножения используется число 6 (префикс поднял значение 5 до умножения) и 2 (постфикс поднял значение 2 только после выполнения операции, а значит, на текущие вычисления это не повлияло). Получается 12. У переменной nr1 постфиксный оператор, поэтому он будет исполнен после операции сложения. Таким образом, результатом сложения 12 и 4 будет 16.
</p>
<h3>Сочетание операторов</h3>
<p>
  Можно создавать сочетания операторов, и работать они будут так же, как и в ма- тематике. Они будут исполняться точно в том же порядке, и совершенно не обя- зательно слева направо. Это происходит благодаря явлению, называемому прио­ ритетом оператора.
</p>
<p>Есть еще одна деталь, которую следует принять во внимание, — группировка. Вы можете группировать операторы с помощью ( и ). Операции, заключенные в круглые скобки, имеют наивысший приоритет. После этого порядок операций определяется в зависимости от их типа (сначала с наивысшим приоритетом). Если операции имеют одинаковый приоритет, они выполняются слева направо.</p>
<p></p>
<table>
  <thead>
      <tr>
          <th>Название</th>
          <th>Символ</th>
          <th>Пример</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Группирование</td>
          <td>(...)</td>
          <td>(x + y)</td>
      </tr>
      <tr>
          <td>Возведение в степень</td>
          <td>**</td>
          <td>x ** y</td>
      </tr>
  </tbody>
  <tfoot>
      <tr>
          <td>Префиксы инкремент и декремент</td>
          <td>--, ++</td>
          <td>--x, ++y</td> 
      </tr>
  </tfoot>
  <tfoot>
    <tr>
        <td>Умножение, деление, модуляция</td>
        <td>*, /, %</td>
        <td>x * y, x / y, x % y</td> 
    </tr>
</tfoot>
<tfoot>
  <tr>
      <td>Сложение и вычитание</td>
      <td>+, -</td>
      <td>x + y, x - y</td>
  </tr>
</tfoot>
</table>
<div class="practicalWrapper">
  <h3 class="practical">Практическое занятие 2.3</h3>
<p>Напишите фрагмент кода для вычисления гипотенузы треугольника с ис- пользованием теоремы Пифагора при заданных значениях двух других сторон. Теорема гласит, что отношение между сторонами прямоугольного треугольника выражается так: a2 + b2 = c2.</p>
<p class="center">Теорема Пифагора применима только к прямоугольным треуголь- никам. Стороны, соединенные под углом 90 градусов, называются катетами (в формуле обозначены как a и b). Самая длинная сто- рона, не прилегающая к прямому углу, называется гипотенузой, обозначена буквой c.</p>
<p>Чтобы получить значение для a и b, можно использовать prompt(). Напишите код, который будет запрашивать от пользователя длину катетов a и b. Затем возведите значения a и b в квадрат. После сложите результаты и извлеките квадратный корень. Полученное значение выведите на экран.</p>
<button>решение</button>
</div>
<h3>Операторы присваивания</h3>
<p>
  Мы уже видели один назначающий оператор, когда присваивали значения пере- менным. Для операции присваивания чаще всего используется знак =. Но есть несколько других способов. Каждый двоичный арифметический оператор имеет соответствующий оператор присваивания — так можно сделать написанный код короче. Например,x += 5 означает x = x+5, а x** = 3 означает x = x**3 (x в степени 3).</p>
  <p>В этом примере мы объявим переменную x и зададим ей начальное значение 2:</p>
  <code>
    let x = 2;<br>
x += 2;<br>
  </code>
  <p>После операции присваивания значение x стало 4, потому что x += 2 — это то же самое, что x = x + 2.</p>
  <p>В следующей операции присваивания мы вычтем 2:</p>
  <code>
    x -= 2;<br>
  </code>
  <p>После этой операции x снова примет значение 2 (x = x – 2). Далее мы умножим значение на 6:
  </p>
  <code>
x *= 6;<br>
  </code>
  <p>Когда эта строка кода будет исполнена, значение x с 2 изменится на 12 (x = x * 6). В следующей строке мы используем оператор присваивания, чтобы продемонстри- ровать деление:</p>
  <code>
    x /= 3;<br>
  </code>
  <p>После деления x на 3 получим значение 4. Далее мы используем оператор присва-
    ивания для возведения в степень:
    </p>
    <code>
      x **= 2;<br>
    </code>
    <p>Значение x теперь равно 16, потому что предыдущее значение 4, возведенное в сте- пень 2, равняется 16 (4 × 4). Последний оператор присваивания продемонстрирует модуляцию:
    </p>
    <code>
      x %= 3;<br>
    </code>
    <p>После выполнения этого оператора значение x стало равно 1, потому что 3 поме-
      щается 5 раз в числе 16 и остается 1.</p>
      <div class="practicalWrapper">
        <h3 class="practical">Практическое занятие 2.4</h3>
        <p>Создайте три численные переменные: a, b и c. Обновите эти переменные с помощью следующих действий, используя операторы присваивания:
        </p>
        <ul>
          <li>сложите b и a;</li>
          <li>разделите a на c;</li>
          <li>замените значение модуляцией c и b;</li>
          <li>выведите все три числа на экран.</li>
        </ul>
      </div>
      <h3>Операторы сравнения</h3>
      <p>Сравнительные операторы отличаются от тех, которые мы уже рассмотрели. Результат их действия всегда принимает значение типа Boolean: true или false.</p>
      <h4>Равно</h4>
      <p>Существует несколько операторов равенства, которые определяют, равны ли два значения. Они бывают двух видов: только равное значение или равные значение и тип данных. Первый возвращает значение true, когда значения равны, даже если тип отличается, в то время как второй возвращает значение true только тогда, когда значение и тип данных совпадают:</p>
      <code>
        let x = 5;<br>
let y = "5";<br>
console.log(x == y); // true<br>
console.log(x === y); // false<br>
      </code>
      <p> == Оператор double equals (двойной знак равно) означает, что сравниваться будут толь- ко значения, но не типы данных. Если обе переменные имеют значение 5, в консоли выводится true. Такой тип равенства обычно <span class="codeText"> == называют свободным равенством.</span></p>
<p>=== Оператор triple equals (три знака равно) означает, что он будет оценивать как значение, так и тип данных, чтобы определить, равны ли обе переменные или нет. Чтобы этот оператор отправил значение true, они должны быть тождественно равны, но в нашем случае это не так, поэтому оператор вернет значение false:</p>
<p>Также данный оператор <span class="codeText"> === называется строгим равенством</span>. Тройное равенство ис- пользуется в большинстве случаев, когда нужно проверить равенство, так как только с его помощью вы можете быть уверены, что обе переменные действительно равны.</p>
<h3>Не равно !=</h3>
<p>Не равно очень похоже на равно, только оно делает все наоборот — возвращает true, когда две переменные не равны, и false, когда равны. Для обозначения этого оператора используется восклицательный знак перед знаком равно:</p>
<code>let x = 5; <br>
  let y = "5"; <br>
  console.log(x != y); // false<br>
</code>
<p>
  Этот код вернет в консоль значение false. Если вам интересно, как все работает,
   взгляните еще раз на операторы double и triple equals: 
   у операторов неравнознач- ности принцип действия аналогичный.
    <span class="codeText">Когда в операторе есть только один знак равенства, он не проводит строгое сравнение и возвращает результат false</span>,
     если приходит к выводу, что переменные равны. <span class="codeText">Оператор, у которого два знака равенства, 
      проверяет строгое несоответствие</span>:</p>
  <code>console.log(x !== y); // true</code>
  <p>Пока у x и y типы данных разные, операнды не равны, поэтому выводится значе-
    ние true.</p>
    <h3>Больше и меньше</h3>
    <p><span class="codeText">Оператор «больше» возвращает значение true, если левая часть уравнения больше правой</span>. Для обозначения этого оператора используется знак >. Есть также 
      <span class="codeText">оператор «больше либо равно», >=, который возвращает true, если левая часть больше или равна правой части</span>.</p>
    <code>let x = 5;<br>
      let y = 6;<br>
      console.log(y > x); // true<br>
    </code>
    <p>В консоли будет зафиксировано значение true, потому что y больше, чем x.</p>
    <code>
      console.log(x > y) // false;
    </code>
    <p>Пока значение x будет меньше, чем значение y, это выражение будет возвращать значение false.</p>
    <code>
      console.log(y > y) // false;
    </code>
    <p>Значение y не больше y, поэтому результатом будет false.</p>
    <code>
      console.log(y >= y); // true
    </code>
    <p>Этот оператор проверяет, будет ли y больше или равен y; пока это условие соблю- дается, значение будет true.</p>
    <p>Логично, что есть также операторы «меньше» (<) и «меньше либо равно» (<=). Они очень похожи на предыдущие.</p>
    <code>console.log(y < x); // false</code>
    <p>Первый оператор будет выдавать результат false, пока y больше x.</p>
    <code>console.log(x < y); // true</code>
    <p>Второй выдает true, потому что x меньше y.</p>
    <code>console.log(y < y); // false</code>
    <p>Значение y не меньше y, поэтому результатом будет false.</p>
    <code>console.log(y <= y); //true</code>
    <p>Этот оператор проверяет, будет ли y меньше или равен y. Переменные y равны, поэтому результатом будет true.</p>
    </section>
    <section class="main-section" id="LogicalOperators">
      <header class="title">Логические операторы</header>
      <p>
        Логические операторы используются всякий раз, когда нужно проверить два усло- вия в одном или отменить условие. Можно использовать «И», «ИЛИ» и «НЕ».</p>
        <h3 id="and">«И» (&&)</h3>
        <p>Рассмотрим первый оператор «И». Если вы хотите проверить, что x действительно больше y и y больше z, вы должны суметь объединить эти два выражения. Это мож- но реализовать с помощью оператора &&. 
          <span class="codeText">Он вернет значение true, только если оба выражения правдивы:</span></p>
        <code>
          let x = 1;<br>
let y = 2;<br>
let z = 3;<br>
        </code>
        <p>Используя эти переменные, мы рассмотрим логические операторы:</p>
        <code>
          console.log(x < y && y < z); // true
        </code>
        <p>
          Это выражение выдаст значение true. 
          <span class="codeText">Его можно расшифровать как «если x меньше y и y меньше z, результат будет true»</span>. Выражение верно, поэтому мы и получим true. Следующий пример выдаст результат false:
        </p>
        <code>
          console.log(x > y && y < z); // false
        </code>
        <p>Поскольку значение x не превышает y, одна часть выражения не соответствует
          действительности, это приведет к значению false.</p>
          <h3 id="or">«ИЛИ» (||)</h3>
          <p>Если вы хотите получить значение true, даже если всего одно из выражений ис- тинно, стоит использовать «ИЛИ». Оператор «ИЛИ» выглядит так — ||. Данные прямые линии используются для проверки того, является ли одно из двух пред- ставленных выражений истинным — в таком случае все выражение оценивается как true. Рассмотрим оператор «ИЛИ» в действии:</p>
          <code>
            console.log(x > y || y < z);
          </code>
          <p>Выражение приведет к результату true, в то время как при использовании && оно принимало значение false. Это связано с тем, что только одна из двух частей долж- на быть истинной, чтобы все выражение оценивалось как true. В данном случае y действительно меньше z.</p>
          <p>Если обе части выражения неверны, то будет возвращено значение false, как в следующем случае:</p>
          <code>console.log(x > y || y > z);</code>
          <h3 id="not">«НЕ» (!)</h3>
          <p>В некоторых случаях вам потребуется отрицать логическую переменную. Это действие изменит текущее значение на противоположное. Отрицание можно реа- лизовать с помощью восклицательного знака, который означает «не»:</p>
          <code>
            let x = false;<br>
console.log(!x);<br>
          </code>
          <p>
            Результат в консоли будет регистрироваться как true, поскольку оператор просто изменит логическое значение на противоположное. Вы также можете отрицать выражение, которое вычисляется как логическое значение, но вам при- дется сначала его сгруппировать, дабы убедиться, что оно вычисляется в первую очередь.</p>
            <code>
              let x = 1;<br>
let y = 2;<br>
console.log(!(x < y));<br>
            </code>
            <p>Значение x меньше значения y, поэтому выражение считается true. Но оно от- рицается восклицательным знаком — поэтому на экран будет выведен резуль- тат false.</p>
            <h3>Вопросы для самопроверки</h3>
          <ol>
            <li>К какому типу данных относится следующая переменная?
              <code>const c = "5";</code>
            </li>
            <li>Какой тип данных представляет переменная ниже?
              <code>const c = 91;</code>
            </li>
            <li>Какая из строк обычно считается лучшей, строка 1 или строка 2?
              <code>let empty1 = undefined; //строка 1 <br>
                let empty2 = null; //строка 2</code>
            </li>
            <li>Какой результат после выполнения следующего кода будет выведен на экран?
              <code>
                let a = "Hello";<br>
   a = "world";<br>
   console.log(a);<br>
              </code>
            </li>
            <li>Какой результат выводится в консоли?
              <code>
                let a = "world";<br>
   let b = `Hello ${a}!`;<br>
   console.log(b);<br>
              </code>
            </li>
            <li>Каково значение a?
              <code>
                let a = "Hello";<br>
   a = prompt("world");<br>
   console.log(a);<br>
              </code>
            </li>
            <li>
              Какое значение b будет выведено на экран?
              <code>
                let a = 5;<br>
   let b = 70;<br>
   let c = "5";<br>
   b++;<br>
   console.log(b);<br>
              </code>
            </li>
            <li>Каково значение result?
              <code>
                let result = 3 + 4 * 2 / 8;
              </code>
            </li>
            <li>
              Каковы значения total и total2?
              <code>
                let firstNum = 5;<br>
                let secondNum = 10;<br>
                firstNum++;<br>
                secondNum--;<br>
let total = ++firstNum + secondNum;<br>
console.log(total);<br>
let total2 = 500 + 100 / 5 + total--;<br>
console.log(total2);<br>
              </code>
            </li>
            <li>Какой результат вы увидите на экране?
              <code>
                const a = 5;<br>
const b = 10;<br>
console.log(a > 0 && b > 0);<br>
console.log(a == 5 && b == 4);<br>
console.log(true || false);<br>
console.log(a == 3 || b == 10);<br>
console.log(a == 3 || b == 7);<br>
              </code>
            </li>
          </ol>
    </section>
    <section class="main-section" id="Array">
			<header class="title">Массивы и их свойства</header>
      <p>
        Массивы — это перечни значений. Значения могут быть всех типов, один массив может содержать значения разных типов. Зачастую очень удобно хранить множе- ство значений в одной переменной, например список студентов или продуктов, результаты теста. Как только вы начнете писать скрипты, вам придется очень часто создавать массивы. Скажем, когда вы захотите отслеживать все вводимые данные или когда понадобится список опций для представления пользователю.
      </p>
<h3>Создание массивов</h3>
<p>Как считаете, какая из следующих записей лучшая?</p>
<code>
  arr1 = new Array("purple", "green", "yellow");<br>
arr2 = ["black", "orange", "pink"];<br>
</code>
<p>
  Если вы выбрали второй вариант, с использованием квадратных скобок, — вы пра- вы. Это самый читаемый способ записи для создания массива. С другой стороны, первый вариант может дать неожиданные результаты. Взгляните на обе строки кода. Как думаете, каким будет итог?
</p>
<code>
  arr3 = new Array(10);<br>
arr4 = [10];<br>
</code>
<p>
  Вероятно, вы чувствуете, что здесь что-то не так. Массив с одним значением 10 получится не во всех вариантах. Нужный результат даст только вторая запись, arr4. Первый вариант даст массив с десятью неопределенными значениями. Если логировать значения следующим образом:
</p>
<code>
  console.log(arr3); // [ <10 empty items> ] <br>
console.log(arr4); // [ 10 ]
</code>
<p>
  Спасибо, JavaScript! Это было крайне полезно. Делаем вывод: если только вашей целью не является получение массива с неопределенными значениями, исполь- зуйте квадратные скобки!
</p>
<p>
  Как вы помните, у нас могут быть смешанные массивы, ведь массивы позволяют хранить переменные любого типа. Значения массива не будут преобразованы в один тип данных или что-то в этом роде. JavaScript просто хранит все переменные с их собственным типом данных и значением в массиве:
</p>
<code>
  let arr = ["hi there", 5, true];<br>
console.log(typeof arr[0]); // string <br>
console.log(typeof arr[1]); // number <br>
console.log(typeof arr[2]); // boolean
</code>
<p>
  Еще одна интересная штука о массивах, которую мы здесь рассмотрим, — это результат определения массива с помощью const. Вы можете изменить значения констант массива, но не можете изменить сам массив. Фрагмент кода для демон- страции:
</p>
<code>
  const arr = ["hi there"];<br>
arr[0] = "new value";<br>
console.log(arr[0]); // new value<br>
arr = ["nope, now you are overwriting the array"]; // TypeError: Assignment to constant variable.
</code>
<h3>Доступ к элементам</h3>
<p>
  Прекрасный массив, который мы только что создали, стал бы намного мощнее, если бы мы могли получить доступ к его элементам. Мы можем сделать это, обра- тившись к индексу массива. Мы его сами не указывали, но нам это и не было нуж- но. JavaScript присваивает индекс каждому значению в массиве данных. Первое значение имеет индекс 0, второе — 1, третье — 2 и т. д. Если необходимо вызвать определенное значение по его положению в массиве, можно указать имя массива, добавить квадратные скобки в конце и вписать в них индекс, к которому мы хотим получить доступ. Например:
</p>
<code>
  cars = ["Toyota", "Renault", "Volkswagen"];<br>
console.log(cars[0]); // Toyota<br>
</code>
<p>
  Этот оператор зафиксирует значение Toyota и выведет его на экран, потому что мы вызвали позицию 0 в массиве. В ней содержится первое значение списка.
</p>
<code>
  console.log(cars[1]); // Renault
</code>
<p>
  Вызов позиции с индексом 1 вернет нам значение второго элемента массива —
Renault. Это и будет выведено на экран.
</p>
<code>console.log(cars[2]); // Volkswagen</code>
<p>
  Третьему элементу присвоен индекс 2, поэтому будет выведено его следующее значение — Volkswagen. Как думаете, что произойдет, если мы используем отрица- тельное значение индекса или значение индекса, которое превышает количество существующих значений?
</p>
<code>
  console.log(cars[3]);<br>
console.log(cars[-1]);<br>
</code>
<p>
  Мы не присваивали значение отрицательному или несуществующему индексу, поэтому, когда мы его запрашиваем, значение не определяется. Следовательно, мы получим результат undefined. JavaScript в этом случае не выбросит ошибку.
</p>
<h3>Перезапись элементов</h3>
<p>
  Элементы массива можно перезаписать. Это можно осуществить следующим образом: запросите доступ к конкретному элементу массива, указав его индекс, и присвойте ему новое значение:
</p>
<code>
  cars[0] = "Tesla";<br>
console.log(cars[0]); // Tesla
</code>
<p>
  В консоли появится Tesla, потому что мы переписали старое значение Toyota. Если вывести все данные массива:
</p>
<p>В консоли появится Tesla, потому что мы переписали старое значение Toyota. Если вывести все данные массива:</p>
<code>
  console.log(cars); // [ 'Tesla', 'Renault', 'Volkswagen' ]
</code>
<p>
  Что произойдет, если вы попытаетесь перезаписать данные элемента, которого не существует?
</p>
<code>
  cars[3] = "Kia";
</code>
<p>
  Или элемента с отрицательным значением индекса?
</p>
<code>
  cars[-1] = "Fiat";
</code>
<p>
  Давайте попытаемся вывести данные массива на экран:
</p>
<code>

console.log(cars[3]); // Kia<br> 
console.log(cars[-1]); // Fiat<br> 
</code>
<p>
  Этот способ добавления значений в массив — неправильный. 
</p>
<h3>Встроенное свойство длины</h3>
<p>Массивы обладают очень полезным свойством: длиной. Она возвращает количество значений, которые содержит массив:</p>
<code>
  colors = ["black", "orange", "pink"] <br>
booleans = [true, false, false, true]; <br>
emptyArray = [];<br>
console.log("Length of colors:", colors.length); // Length of colors: 3<br>
console.log("Length of booleans:", booleans.length); // Length of booleans: 4<br>
console.log("Length of empty array:", emptyArray.length); // Length of empty array: 0<br>
</code>
<p>
  Первый вызов console.log вернет значение 3, указывая, что массив цветов содер- жит три значения. Второй выдаст значение 4, а последний — это пустой массив со значением длины 0:
</p>
<p>
  Имейте в виду, что длина на единицу превышает максимальный индекс (потому что индекс массива начинается с 0). 
 <span class="codeText"> Но при определении длины мы оцениваем количество элементов</span> — и видим четыре отдельных элемента. Поэтому максимальный индекс — 3 при длине массива 4. Следовательно, позиционное значение последнего элемента в массиве будет на единицу меньше, чем общее количество элементов.
</p>
<code>
  lastElement = colors[colors.length - 1];
</code>
<p>
  Вы получите наивысший индекс, вычитая 1 из длины, потому что, как вы знаете, массивы индексируются, начиная с нулевого значения. Таким образом, позицион- ное значение последнего элемента в массиве будет на единицу меньше, чем общее количество элементов.
</p>
<p>
  Кажется, все довольно просто. Помните, мы брали несуществующую индексную
позицию в предыдущем разделе? Посмотрим, что произойдет в данном примере:
</p>
<code>
  numbers = [12, 24, 36];<br>
numbers[5] = 48;<br>
console.log(numbers.length); // 6<br> 
</code>
<p>
  Длина массива учитывает только целые числа, начиная с 0 и заканчивая самым высоким значением индекса заполненной ячейки. Если в середине последова- тельности есть элементы, которым не присвоено значение, они все равно будут подсчитаны. В таком случае значение длины становится равным 6. Если логируете массив, вы увидите почему:
</p>
<code>
  console.log("numbers", numbers); //  numbers [ 12, 24, 36, <2 empty items>, 48 ]
</code>
<p>
  Поскольку мы добавили значение 48 в позицию с индексом 5, массив создал два пустых элемента с индексами 3 и 4. А теперь давайте рассмотрим методы работы с массивами и определим правильный способ добавления значений в массив.
</p>
<div class="practicalWrapper">
  <h3 class="practical">Практическое занятие 3.1</h3>
<ol>
  <li>Создайте массив — список покупок, состоящий из трех единиц: Milk, Bread и Apples.</li>
  <li>Проверьте длину списка в консоли.</li>
  <li>Обновите данные второй ячейки и замените Bread на Bananas.</li>
  <li>Выведите весь список на экран.</li>
</ol>
<button>решение</button>
</div>
<h3>Методы работы с массивами</h3>
<p>
  <span class="codeText">Методы — это функции для определенного объекта.</span> Они не удерживают значение (например, свойства), а выполняют действия. 
  Нужно знать только то, что вы можете вызывать методы и функции и, когда вы это делаете, выполняется некоторый код, записанный внутри этих функций.
</p>
<p>Добавлять элементы, используя новые индексы. Это неправильный путь: так легко совершить ошибку и случайно перезаписать
  определенное значение или пропустить определенный индекс. Правильнее всего будет добавить элементы с помощью специального метода. Таким же способом мы можем удалять элементы в массиве и сортировать их.
</p>
<h3>Добавление и замена элементов</h3>
<p>Метод push()</p>
<code>
  favoriteFruits = ["grapefruit", "orange", "lemon"]; <br>
favoriteFruits.push("tangerine"); <br>
</code>
<p>
  <span class="codeText">Значение добавляется в конец массива.</span> Метод push возвращает новую длину массива (в данном случае 4). Вы можете сохранить ее в переменной типа этой:
</p>
<code>
  let lengthOfFavoriteFruits = favoriteFruits.push("lime"); // [ 'grapefruit', 'orange', 'lemon', 'tangerine', 'lime' ]
</code>
<p>
  В переменной lengthOfFavoriteFruits сохранилось значение 5. Если мы логируем favoriteFruits:
</p>
<p>Метод splice()</p>
<p>
  Но что, если вы захотите добавить элементы с определенным индексом? В таком случае необходимо использовать метод splice(). Он немного сложнее:
</p>
<code>
  let arrOfShapes = ["circle", "triangle", "rectangle", "pentagon"]; <br>
arrOfShapes.splice(2, 0, "square", "trapezoid"); <br>
console.log(arrOfShapes); <br> 
[<br>
'circle',<br>
'triangle',<br>
'square',<br>
'trapezoid',<br>
'rectangle',<br>
'pentagon'<br>
]
</code>
<p>
  Сначала обратим внимание на то, что значения в консоли вывелись не в строку, а в столбец. Все зависит от используемого вами интерпретатора: в какой-то момент он решит, что массив слишком длинный для одной строки, и применит автоформатирование, чтобы сделать массив более читабельным. Значение массива при этом не изменится — это просто другая форма представления одних и тех же значений.
</p>
<p>
  Как вы могли заметить, квадрат (square) и трапеция (trapezoid) вставляются в индекс 2. Остальная часть массива смещается вправо. Метод splice() использует несколько параметров.
   <span class="codeText">Первый параметр (в нашем случае 2) — это индекс массива, с которого мы хотим начать делать вставку.</span>
    <span class="codeText">Второй параметр (в нашем случае 0) — это число элементов, которые мы хотим удалить</span>, 
    начиная с ранее определенного стартового значения. После этих двух параметров следуют значения (в нашем случае square и trapezoid), которые требуется внести, начиная с определенного индекса.
</p>
<p>
  Если вместо этого мы введем:
</p>
<code>
  arrOfShapes.splice(2, 2, "square", "trapezoid");<br>
console.log(arrOfShapes); // [ 'circle', 'triangle', 'square', 'trapezoid' ]<br>
</code>
<p>
  программа удалит элементы со значениями rectangle и pentagon и добавит вместо них значения square и trapezoid:
</p>
<p>
  Если увеличить второй параметр до числа, превышающего размер массива, резуль- тат не изменится. В этом случае JavaScript просто остановится, как только у него закончатся значения для удаления. Попробуйте ввести следующий код:
</p>
<code>
  arrOfShapes.splice(2, 12, "square", "trapezoid");<br>
console.log(arrOfShapes); // [ 'circle', 'triangle', 'square', 'trapezoid' ]<br>
</code>
<p>Метод concat()</p>
<p>
Вы также можете добавить массив в существующий массив. Для этого необходимо использовать метод concat(). Так у вас появится новый массив — объединение обоих массивов. Элементы первого массива будут первыми, а элементы метода concat() будут собраны к концу:
</p>
<code>
  let arr5 = [1, 2, 3]; <br>
let arr6 = [4, 5, 6]; <br>
let arr7 = arr5.concat(arr6); <br>
console.log(arr7); // [ 1, 2, 3, 4, 5, 6 ]<br>
</code>
<p>
  Но метод concat() способен на большее! Мы также можем использовать его для добавления значений. Мы можем добавить одно значение или разделить несколько значений запятыми:
</p>
<code>
  let arr8 = arr7.concat(7, 8, 9,"string");<br>
console.log(arr8); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9,'string']
</code>
<h3>Удаление элементов</h3>
<p>Метод pop()</p>
<p>
  Есть несколько способов удалить элементы из массива. Убрать последний элемент можно с помощью метода pop():
</p>
<code>
  arr8 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9,'string'] <br>
  arr8.pop() <br>
  console.log(arr8); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code>
<p>Метод shift()</p>
<p>Удаление первого элемента производится с помощью метода shift(). Это приводит к уменьшению всех оставшихся индексов на единицу:</p>
<code>
  arr8.shift(); <br>
  console.log(arr8); // [ 2, 3, 4, 5, 6, 7, 8, 9]
</code>
<p>
  Метод splice() Это особенный метод, который также может использоваться для удаления значений. Мы указываем индекс, с которого хотим начать удаление, а затем количество элементов, которые нужно удалить.
</p>
<code>
  arr8.splice(1, 3);<br>
  console.log(arr8); // [ 2, 6, 7, 8, 9]
</code>
<p>
  Три элемента, начиная со второй позиции, были удалены. Значения 3, 4 и 5 исчезли. Если не хотите изменять какие-либо из следующих далее индексов, вы можете использовать оператор delete. Это не метод, но он также способен из- менить значение определенной позиции массива на undefined:
</p>
<code>
  delete arr8[0]; <br>
  onsole.log(arr8); // [ <1 empty item>, 3, 4, 5, 6, 7, 8, 9 ]
</code>
<p>
  Это полезно, когда ваши действия по какой-либо причине зависят от индекса или длины массива. Например, если вы сохраняете данные, введенные пользователем,
  и хотите определить количество вводов на основе массива, к которому пользователь обращается. В этом случае удаление приведет к уменьшению количества вводов и, скорее всего, вы получите не тот результат, который вам требовался.
</p>
<h3>Поиск элементов</h3>
<p>Метод find()</p>
<p>
  Если вам требуется проверить, присутствует ли значение в массиве, вы можете использовать метод find(). Он работает несколько иначе. <span class="codeText">find() На самом деле это функция</span> , которая будет применяться к каждому элементу массива, пока не найдет совпадения. Если совпадений не встретится, функция вернет значе- ние undefined.
</p>
<p>
 В следующем фрагменте кода мы записываем функцию двумя разными способами. На самом деле обе строки делают одно и то же, только первая ищет элемент, равный 6, а вторая — элемент, равный 10:
</p>
<code>
  arr8 = [ 2, 6, 7, 8, ]; <br>
let findValue = arr8.find(function(e) { return e === 6});<br>
let findValue2 = arr8.find(e => e === 10);<br>
console.log(findValue, findValue2);<br>
</code>
<p>
  Оператор вывода выдает 6 и undefined, потому что функция нашла число, равное 6, но не нашла совпадений для числа 10.
</p>
<p>
  Функция может принимать некоторые входные данные. В нашем случае за входные данные будет принят элемент массива.
   Если элемент массива равен 6 (findValue) или 10 (findValue2), функция вернет это значение.
</p>
<p>Метод indexOf()</p>
<p>
  Часто вам понадобится не только найти элемент, но и узнать, на какой позиции он находится. Это можно реализовать с помощью метода indexOf(). Он возвращает значение индекса, по которому найдено значение. Если значение встречается в массиве несколько раз, метод вернет индекс первого совпадения. Если значение не найдено, вернется значение -1:
</p>
<code>
  arr8 = [ 2, 6, 7, 8 ]; <br>
let findIndex = arr8.indexOf(6);<br>
let findIndex2 = arr8.indexOf(10);<br>
console.log(findIndex, findIndex2); // 1 -1<br>
</code>
<p>
  Таким образом, первый метод вернет 1 — это индекс позиции со значением 6. Второй вернет значение –1, потому что в массиве нет числа 10.
</p>
<p>
  Чтобы узнать, где еще находится конкретное значение, помимо первого совпадения, можете добавить второй аргумент indexOf(), указав, с какой позиции он должен начать поиск:
</p>
<code>
  arr8 = [ 2, 6, 7, 8 ]; <br>
let findIndex3 = arr8.indexOf(6, 2);
</code>
<p>
  В этом случае значение findIndex3 будет равно –1, поскольку 6 не может быть найдено, если поиск начнется со значения индекса 2.
</p>
<code>
  arr8 = [1, 2, 3, 4, 5, 6, 7, 8 ];<br>
  let findIndex4 = arr8.indexOf(5, 0); <br>
console.log(findIndex4) // 4
</code>
<p>Метод lastIndexOf()</p>
<p>
  Мы также можем найти последнее совпадение — с помощью метода lastIndexOf():
</p>
<code>
  let animals = ["dog", "horse", "cat", "platypus", "dog"];<br>
let lastDog = animals.lastIndexOf("dog");<br>
console.log(lastDog) // 4
</code>
<h3>Сортировка</h3>
<p>Метод sort()</p>
<p>
  Существует также встроенный метод сортировки массивов.
   <span class="codeText">Он сортирует числа от маленьких до больших и располагает строки от А к Z</span>. Вы можете вызвать sort() для массива — и порядок значений массива изменится в зависимости от вида сортировки:
</p>
<code>
  let names = ["James", "Alicia", "Fatiha", "Maria", "Bert"];<br>
  console.log(names.sort()) // [ 'Alicia', 'Bert', 'Fatiha', 'James', 'Maria' ]
</code>
<p>
  Теперь элементы массива расположены в алфавитном порядке. Что касается чисел, то они сортируются в порядке возрастания, как вы можете видеть в следующем фрагменте кода:
</p>
<code>
  let ages = [18, 72, 33, 56, 40];<br>
  console.log(ages.sort()) // [ 18, 33, 40, 56, 72 ]
</code>
<p>
  Сортировка чисел (без функции сравнения):
</p>
<code>
  let arr = [3, -1, 4, -5, 2, -9, 0];<br>
arr.sort();<br>
console.log(arr); // [-1, -5, -9, 0, 2, 3, 4] (неправильная сортировка для чисел)
</code>
<p>
  Сортировка чисел (с функцией сравнения):
</p>
<code>
  let arr = [3, -1, 4, -5, 2, -9, 0]; <br>
arr.sort((a, b) => a - b); <br>
console.log(arr); // [-9, -5, -1, 0, 2, 3, 4] (правильная сортировка для чисел)
</code>
<p>
  Сортировка чисел в обратном порядке:
</p>
<code>
  let arr = [3, -1, 4, -5, 2, -9, 0];<br>
arr.sort((a, b) => b - a);<br>
console.log(arr); // [4, 3, 2, 0, -1, -5, -9] (правильная сортировка для чисел в обратном порядке)
</code>
<p>Метод reverse()</p>
<p>
  Элементы массива можно поменять местами, вызвав встроенный метод reverse(). Он поставит последний элемент первым, а первый элемент — последним. Не имеет значения, отсортирован массив или нет; метод просто поменяет порядок.
</p>
<code>
  names = [ 'Alicia', 'Bert', 'Fatiha', 'James', 'Maria' ] <br>
  console.log(names.reverse()) // [ 'Maria', 'James', 'Fatiha', 'Bert', 'Alicia' ]
</code>

<div class="practicalWrapper">
  <h3 class="practical">Практическое занятие 3.2</h3>
<ol>
  <li>Создайте массив — список покупок в продуктовом магазине.</li>
  <li>Добавьте в список Milk, Bread и Apples.</li>
  <li>Замените Bread на Bananas и Eggs.</li>
  <li>Удалите последний элемент из массива и выведите его на экран.</li>
  <li>Отсортируйте список в алфавитном порядке.</li>
  <li>Найдите и выведите значение индекса Milk.</li>
  <li>После Bananas добавьте Carrots и Lettuce.</li>
  <li>Создайте новый список, в котором будет Juice и Pop.</li>
  <li>Объедините оба списка, добавив новый список дважды в конец первого списка.</li>
  <li>Получите последнее значение индекса Pop и выведите его на экран.</li>
  <li>ВИтоговый результат должен быть таким:</li>
  <code>
    ["Bananas", "Carrots", "Lettuce", "Eggs", "Milk", "Juice",
    "Pop", "Juice", "Pop"]
  </code>
</ol>
<button>решение</button>
</div>
<h3>Многомерные массивы</h3>
<p>
  Массивы могут содержать любые типы данных. Это означает, что массивы также могут содержать другие массивы (которые, в свою очередь, могут содержать... другие массивы!). Это называется многомерным массивом. Звучит сложно, но перед вами всего лишь массив массивов — список списков:
</p>
<code>
  let someValues1 = [1, 2, 3];<br>
let someValues2 = [4, 5, 6];<br>
let someValues3 = [7, 8, 9];<br>
let arrOfArrays = [someValues1, someValues2, someValues3];<br>
</code>
<p>
  Таким образом, мы можем создать массив из существующих массивов — он будет называться двумерным. Записать его можно так:
</p>
<code>
  let arrOfArrays2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
</code>
<p>
  <span class="codeText">Если потребуется получить доступ к элементам внутренних массивов, то указывать индекс придется дважды:</span>
</p>
<code>
  let value1 = arrOfArrays[0][1];
</code>
<p>
  Оператор охватит первый массив — индекс 0. Из этого первого массива он при- мет второе значение (индекс 1). Затем он сохранит это значение в переменной value1 — так значение value1 станет равно 2.
</p>
<div class="practicalWrapper">
  <h3 class="practical">Практическое занятие 3.3</h3>
<ol>
  <li>Создайте массив, содержащий три значения: 1, 2 и 3.</li>
  <li>Трижды вложите исходный массив в новый массив.</li>
  <li>Выведите на экран значение 2 из любого массива.</li>
</ol>
<button>решение</button>
</div>
      </section>
      <section class="main-section" id="Primitives">
        <header class="title">Объекты</header>
        <p>
          Объекты очень полезны и могут исполь- зоваться для описания реальных предметов, а также более сложных абстрактных понятий, которые обеспечивают большую гибкость в коде.
        </p>
        <p>
          массивы — это особен- ный тип объектов, объектов с индексированными свойствами. Все остальные объекты (а также объекты, которые мы рассмотрим в данном разделе) являются объектами с именованными свойствами. Это значит, что вместо автоматически сгенерированного индексного номера мы присвоим им пользовательские описательные имена.
        </p>
        <p>
          Следующий код подтверждает, что тип массивов определяется JavaScript как объектный:
        </p>
        <code>
          let arr = [0, 1, 2];<br>
console.log(typeof arr); // Object
        </code>
        <p>
          Объекты не так уж сильно отличаются от предметов реального мира. 
          У них есть свойства, и они могут выполнять действия, методы.
          Объект — это возможность сгруппировать несколько переменных в одну, 
          что делается с помощью фигурных скобок: { и }. Давайте рассмотрим следующий объект — собаку:
        </p>
        <code>
          let dog = { dogName: "JavaScript",<br>
            weight: 2.4,<br>
            color: "brown",<br>
            breed: "chihuahua",<br>
            age: 3,<br>
            burglarBiter: true<br>
};
        </code>
        <p>
          Мы создали переменную dog и присвоили этому объекту значение. Распознать, что это объект, можно по фигурным скобкам: { и }. Между ними находится множество свойств объекта и их значений.
        </p>
        <p>
          Если вы когда-нибудь задавались вопросом, является ли что-то свойством или нет, просто взгляните на следующее шаблонное предложение:
        </p>
        <p>
          <span class="codeText">у *название_объекта* есть *название_свойства*</span>
        </p>
        <p>
          Например, у собаки есть имя, у собаки есть цвет и у собаки есть вес. Логические свойства определяются по-другому: вместо «есть» в предложение подставляются «является» или «не является».
        </p>
        <p>
          Мы можем получить доступ к свойствам объекта по очень похожей на случай с мас- сивом схеме. Но на этот раз, чтобы получить значение, мы используем не номер индекса, а название свойства:
        </p>
        <code>
          let dogColor1 = dog["color"];
        </code>
        <p>
          Есть и другой способ прийти к такому результату. Вместо использования квадрат- ных скобок можно записать имя объекта и имя свойства через точку:
        </p>
        <code>
          let dogColor2 = dog.color;
        </code>
        <p>
          Такой формат может показаться знакомым. Помните, как мы получили длину массива со встроенным свойством length? Да — точно так же!
           <span class="codeText">Разница между свойствами и методами заключается в отсутствии у первых круглых скобок.</span>
        </p>
        <h3>Обновление объектов</h3>
        <p>
          Мы можем изменять значения свойств объектов. Опять же с массивами мы работали похожим образом, потому что массив также является объектом, но, что касается свойств, у нас есть два варианта:
        </p>
        <code>
          dog["color"] = "blue";<br>
dog.weight = 2.3;
        </code>
        <p>
          Код изменил свойства нашей чихуахуа. Цвет стал синим, а сама собака немного потеряла в весе (на 0,1). Если вывести данные о собаке:
        </p>
        <code>
          console.log(dog);<br>
          {<br>
            dogName: 'JavaScript',<br>
            weight: 2.3,<br>
            color: 'blue',<br>
            breed: 'chihuahua',<br>
age: 3,<br>
burglarBiter: true<br>
}
        </code>
        <p>
          Полезно помнить, что, если мы изменим тип данных одного из свойств, например:
        </p>
        <code>
          dog["age"] = "three";
        </code>
        <p>
          JavaScript не воспримет это как проблему, а просто изменит все значения и тип данных в соответствии с новой ситуацией.
        </p>
        <p>
          Еще одна деталь, которую следует отметить: теперь, чтобы сослаться на свойства объекта, мы используем литеральные значения, но мы также можем работать с переменными. Например:
        </p>
        <code>
          let variable = "age";<br>
console.log(dog[variable]);
        </code>
        <p>
          <span class="codeText">Программа все равно выведет three</span>, так как мы только что изменили значение возраста на три. Если изменить значение переменной на другое свойство собаки, мы получим к нему доступ:
        </p>
        <code>
          variable = "breed";<br>
console.log(dog[variable]);
        </code>
        <p>
          Код выведет в консоль chihuahua. Когда мы обновляем значение, полученное подобным образом, все произойдет так же, как если бы мы обращались к нему с помощью литеральной строки:
        </p>
        <code>
          dog[variable] = "dachshund"; <br>
console.log(dog["breed"]);
        </code>
        <p>
          Эта строка вернет значение dachshund в консоль.
        </p>
        <div class="practicalWrapper">
          <h3 class="practical">Практическое занятие 3.4</h3>
        <ol>
          <li>Создайте новый объект myCar для описания автомобиля. Добавьте не- сколько свойств, включая make и model (не ограничивайтесь только ими), и значения, характерные для любого или вашего автомобиля. Смело ис- пользуйте логические значения, строки или числа.</li>
          <li>Создайте переменную color, которая может содержать значение типа string. Эта переменная теперь может использоваться для ссылки на имя свойства объекта myCar. Затем включите переменную в квадратные скоб- ки, чтобы присвоить новое значение цвета для myCar.</li>
          <li>Возьмите ту же переменную и назначьте ей новое свойство типа string, например forSale. Снова используйте скобки, чтобы присвоить значение свойству forSale, указывающее, выставлен ли автомобиль на продажу.</li>
          <li>Выведите make и model на экран.</li>
          <li>
            Выведите значение forSale на экран.
          </li>
        </ol>
        <button>решение</button>
        </div>
      </section>
    </section>
    <section class="main-section" id="Primitives">
      <header class="title">Объекты внутри объектов</header>
    </section>

    <section class="main-section" id="Projects">
      <header class="title">Проекты</header>
      <h3 class="practical">Проекты главы 2</h3>
      <h3>Конвертер миль в километры</h3>
      <p>Создайте переменную, содержащую значение в милях, преобразуйте ее в километры и запишите значение в километрах в следующем формате:</p>
      <code>
        Расстояние 130 миль. равно 209,2142 км
      </code>
      <h3>Вычислитель индекса массы тела (ИМТ)</h3>
      <p>Установите значения для роста в дюймах и веса в фунтах, затем преобразуйте значения в сантиметры и килограммы:</p>
      <ul>
        <li>1 дюйм равен 2,54 см;</li>
        <li>2,2046 фунта равны 1 кг.</li>
      </ul>
      <p>Выведите результаты. Затем рассчитайте и запишите ИМТ: он равен весу (в кило- граммах), деленному на квадрат роста (в метрах). Выведите результаты на экран.</p>
    </section>
    <div class="void" id="bottom"></div>
    <!-- <section class="main-section" id="Mathematics">
      <header class="title">Математика</header>
      <h3>Квадратный корень</h3>
      <p>Квадратный корень — это математическая операция, обратная возведению числа в квадрат. Если x x — это квадратный корень из a a, то x 2 = a x 2 =a. Обозначается это как x = a x= a.</p>
    </section> -->
	</main>
</div>
<script src="script.js"></script>
<script src="./nav.js"></script>
</body>
</html>