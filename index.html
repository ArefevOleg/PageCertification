<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="stylesheet" href="style.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
	<title>JS Documentation</title>
</head>
<body class="body">
<div class="container">
	<nav id="navbar">
		<header class="navTitle title"><span class="accent">JS</span> Documentation</header>
		<ul class="listItem">
			<li class="item"><a href="#Browser" class="nav-link">Работа в браузере</a>
      </li>
			<li class="item"><a href="#Variables" class="nav-link">Переменные</a></li>
			<li class="item item1"><a href="#Primitives" class="nav-link">Примитивные типы данных</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#String" class="nav-link">String</a></li>
          <li class="submenuItem"><a href="#Escape" class="nav-link">Escape-символы</a></li>
          <li class="submenuItem"><a href="#Number" class="nav-link">Number</a></li>
          <li class="submenuItem"><a href="#BigInt" class="nav-link">BigInt</a></li>
          <li class="submenuItem"><a href="#Boolean" class="nav-link">Boolean</a></li>
          <li class="submenuItem"><a href="#Symbol" class="nav-link">Symbol</a></li>
          <li class="submenuItem"><a href="#undefined" class="nav-link">undefined</a></li>
          <li class="submenuItem"><a href="#null" class="nav-link">null</a></li>
      </ul>
    </li>
			<li class="item"><a href="#Analysis" class="nav-link">Анализ и модификация типов данных</a></li>
			<li class="item"><a href="#Operators" class="nav-link">Операторы</a></li>
			<li class="item"><a href="#LogicalOperators" class="nav-link">Логические операторы</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#and" class="nav-link">«И» (&&)</a></li>
          <li class="submenuItem"><a href="#or" class="nav-link">«ИЛИ» (||)</a></li>
          <li class="submenuItem"><a href="#not" class="nav-link">«НЕ» (!)</a></li>
      </ul></li>
			<li class="item"><a href="#Array" class="nav-link">Массивы и их свойства</a>
        <ul class="submenu">
          <li class="submenuItem"><a href="#String" class="nav-link">Создание массивов</a></li>
          <li class="submenuItem"><a href="#Escape" class="nav-link">Доступ к элементам</a></li>
          <li class="submenuItem"><a href="#Number" class="nav-link">Перезапись элементов</a></li>
          <li class="submenuItem"><a href="#BigInt" class="nav-link">Встроенное свойство длины</a></li>
          <li class="submenuItem"><a href="#Boolean" class="nav-link">Методы</a></li>
          <li class="submenuItem"><a href="#Symbol" class="nav-link">Symbol</a></li>
          <li class="submenuItem"><a href="#undefined" class="nav-link">undefined</a></li>
          <li class="submenuItem"><a href="#null" class="nav-link">null</a></li>
      </ul></li>
			<li class="item"><a href="#Global_variables" class="nav-link">Global variables</a></li>
			<li class="item"><a href="#Constants" class="nav-link">Constants</a></li>
			<li class="item"><a href="#Data_types" class="nav-link">Data types</a></li>
			<li class="item"><a href="#if...else_statement" class="nav-link">if...else statement</a></li>
			<li class="item"><a href="#while_statement" class="nav-link">while statement</a></li>
			<li class="item"><a href="#Projects" class="nav-link">Проекты</a></li>
			<li class="item"><a href="#Mathematics" class="nav-link">Математика</a></li>
      <li class="item"><a href="#bottom" class="nav-link">Низ</a></li>
		</ul>
	</nav>
	<main id="main-doc" class="main">
		<section class="main-section" id="Browser">
			<header class="title">JavaScript работа в браузере</header>
			<p>JavaScript является интерпретируемым языком программирования: это значит,
         компьютер распознает его в процессе работы кода.
          Некоторые языки перед за- пуском кода требуют обработки 
          (данный процесс называется компиляцией) — но для JavaScript в этом нет необходимости. 
          Компьютер интерпретирует JavaScript на лету. При этом «движок», понимающий JavaScript, 
          называется интерпрета- тором.
        </p>
		</section>
		<section class="main-section" id="Variables">
			<header class="title">Переменные</header>
			<p>
				Определение переменной состоит из трех частей: определяющего слова <b class="codeText">let, var</b> или <b class="codeText">const</b>, 
        названия и значения.
        <b class="codeText"> let и var</b> используются для переменных, 
        которым где-то в программе может быть присвоено новое значение.
         Различия между let и var не так просты. Они связаны с областью их применения.
			</p>
			<ul>
				<li><b class="codeText">var</b>относится к глобальным переменным
          <p>Глобальность var означает, что вы можете использовать переменную, ранее опреде- ленную как var, в любом месте кода.</p>
				</li>
				<li>
					<b class="codeText">let</b> — локальная переменная
          <p> Область действия let ограничивается только конкретным блоком кода: вы можете использовать переменные, определенные с помо- щью let, только там, где они и были определены. </p>
				</li>
				<li>
					<b class="codeText">const</b>относится к глобальным переменным
          <p>
            Оператор const используется для переменных, которым присваивается значение только один раз,
             например π, которое априори не меняется. Если вы попытаетесь переназначить переменную const,
              система выдаст сообщение об ошибке</p>
              <code>
                const someConstant = 3;<br>
                someConstant = 4;</code>
                <code>Uncaught TypeError: Assignment to constant variable.</code>
				</li>
			</ul>
		</section>
		<section class="main-section" id="Primitives">
			<header class="title">Примитивы</header>
      <h3 id="String">String</h3>
			<p>
				Строковый тип данных используется для передачи текстовых значений. Это последовательность символов. Есть несколько способов объявить переменную строкового типа:
        <ul>
          <li>двойные кавычки;</li>
          <li>одинарные кавычки;</li>
          <li>обратные апострофы: специальные шаблонные строки, в которых вы можете напрямую использовать переменные.</li>
        </ul>
        <p>Так, например, следующее написание приведет к ошибке, потому что строка будет за- канчиваться апострофом внутри слова let's:</p>
        <code>let funActivity = 'Let's learn JavaScript';</code>
			</p>
      <p>Слово Let будет определено как строка, но после него набор символов не будет ин- терпретирован. Но если вы объявите строку, заключив ее в двойные кавычки, стро- ка не завершится, когда достигнет апострофа, потому что программа будет искать другую двойную кавычку. Следовательно, эта альтернатива будет работать лучше:</p>
      <code>let funActivity = "Let's learn JavaScript";</code>
      <p>Аналогичная история с двойными кавычками. Следующий код не будет работать:</p>
      <code>let question = "Do you want to learn JavaScript? "Yes!"";</code>
			<p>
				В строке, использующей обратные апострофы, вы можете ссылаться на перемен- ные — значение переменной будет подставлено в строку. Как во фрагменте кода, представленном ниже:
			</p>
      <code>let language = "JavaScript";<br>
        let message = `Let's learn ${language}`;<br>
        console.log(message);
        </code>
        <h3 id="Escape">Escape-символы</h3>
        <p>Допустим, мы хотим использовать в нашей строке двойные кавычки, одинарные кавычки и обратные апострофы. С теми ингредиентами, которые у нас есть сейчас, сделать подобное невозможно. Но для этой проблемы есть элегантное решение — специальный символ, с помощью которого можно сказать JavaScript: «Не читай следующий символ как обычно». Речь об escape-символе, обратном слеше.</p>
        <p>Обратный слеш может использоваться для того, чтобы интерпретатор не видел одинарные или двойные кавычки и не заканчивал строку слишком рано:</p>
        <code>
          let str = "Hello, what's your name? Is it \"Mike\"?";<br>
          console.log(str);<br>
          let str2 = 'Hello, what\'s your name? Is it "Mike"?';<br>
          console.log(str2);<br>
          В консоли выводится: <br>
 Hello, what's your name? Is it "Mike"?<br>
 Hello, what's your name? Is it "Mike"?<br>
          </code>
          <p>У escape-символа есть много назначений. Вы можете использовать его для созда- ния разрыва строки с помощью \n или для включения символа обратного слеша в текст с помощью \\:</p>
          <code>let str3 = "New \nline."; // перенос на новую строку<br> 
            let str4 = "I'm containing a backslash: \\!";<br>
            console.log(str3);<br>
            console.log(str4);<br>
            </code>
            <h3 id="Number">Number</h3>
            <p>Во многих языках существует очень четкая разница между различными типами чисел. Разработчики JavaScript решили использовать один тип данных для них всех: Number (если точнее, это 64-битное число с плавающей точкой). Этот тип может хранить довольно большие числа (как со знаком, так и без), десятичные дроби и многое другое.</p>
            <p>Существуют различные виды чисел, которые он может представлять. Прежде всего, целые числа, например 4 или 89. Но тип данных Number также может использовать- ся для представления десятичных, экспоненциальных, восьмеричных, шестнадца- теричных и двоичных чисел. Следующий пример кода говорит сам за себя:</p>
            <code>let intNr = 1;<br>
              let decNr = 1.5;<br>
              let expNr = 1.4e15;<br>
let octNr = 0o10; //в десятичной системе будет 8 <br>
let hexNr = 0x3E8; //в десятичной системе будет 1000 <br>
let binNr = 0b101; //в десятичной системе будет 5 <br>
            </code>
            <p>Не стоит переживать насчет последних трех позиций, если вы с ними не зна- комы, это просто разные способы представления чисел, с которыми вы можете столкнуться в более продвинутых задачах информационных технологий. Главное здесь то, что все вышеперечисленные числа относятся к типу данных Number. Итак, целые числа — это числа, подобные этим:</p>
            <code>
              let intNr2 = 3434;<br>
let intNr3 = -111;<br>
Числа с плавающей точкой тоже относятся к типу Number: <br>
let decNr2 = 45.78;<br>
И двоичные числа: <br>
let binNr2 = 0b100; // десятичная версия будет 4 <br>
            </code>
            <h3 id="BigInt">BigInt</h3>
            <p>Диапазон значений типа данных Number находится между 253–1 и –(253–1). BigInt вступает в дело, когда вам требуются числа больше (или меньше) этого интервала. Тип данных BigInt можно узнать по окончанию n:</p>
            <code>let bigNr = 90071992547409920n;</code>
            <p>Рассмотрим, что происходит, когда мы начинаем вычисления между ранее задан- ным целым числом типа Number, intNr, и значением типа BigInt, bigNr:</p>
            <code>let result = bigNr + intNr; <br>
              Результат будет таким: <br>
              Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions
            </code>
            <p>Ошибка типов данных — TypeError! Совершенно ясно: что-то пошло не так. Для выполнения операций нельзя смешивать тип данных BigInt с типом данных Number. Это то, что следует запомнить на будущее, когда вы будете работать с BigInt, — вы можете использовать BigInt только с другими BigInt.</p>
            <h3 id="Boolean">Boolean</h3>
            <p>Логический тип данных Boolean может принимать два значения: true (истина) и false (ложь). И ничего больше. Этот тип данных часто используется в коде, особенно в логических выражениях:</p>
            <code>
              let bool1 = false; <br>
              let bool2 = true;
            </code>
            <h3 id="Symbol">Symbol</h3>
            <p>Символьный тип Symbol совершенно новый и представлен в ES6 (мы упоминали стандарт ECMAScript 6 в главе 1 «Начало работы с JavaScript»). Он может уста- навливаться в случаях, когда важно подчеркнуть, что переменные не равны, даже если их значение и тип одинаковы (в этом случае они обе примут тип символа). Сравните следующие объявления строк с объявлениями символов (и те и другие имеют одинаковое значение):</p>
            <code>
              let str1 = "JavaScript is fun!";<br>
let str2 = "JavaScript is fun!";<br>
console.log("These two strings are the same:", str1 === str2);<br>
let sym1 = Symbol("JavaScript is fun!");<br>
let sym2 = Symbol("JavaScript is fun!");<br>
console.log("These two Symbols are the same:", sym1 === sym2);<br>
Результат будет следующим:<br>
 These two strings are the same: true<br>
 These two Symbols are the same: false<br>
            </code>
            <p>В первой части кода JavaScript приходит к выводу, что строки одинаковые, 
              у них один тип и значение. Однако во второй части кода каждый символ определяется как уникальный. Поэтому,
               хотя содержимое символов одинаковое, они не совпадают и при сравнении выводится значение false.
                <span class="codeText">Эти символьные типы данных могут быть очень удобны в качестве свойств объектов</span>, которые мы рассмотрим в <span class="codeText">главе 3</span>.</p>
        <h3 id="undefined">undefined</h3>
        <code>
          let unassigned; <br>
console.log(unassigned); <br>
Результат будет таким: Undefined
        </code>
        <p>Мы также можем целенаправленно назначать undefined — важно знать, что такое возможно. Но еще важнее знать, что <span class="codeText">присвоение типа undefined вручную — плохая практика:</span></p>
        <p>Да, так можно, но лучше так не делайте. По целому ряду причин — например,<span class="codeText"> в слу- чаях, когда требуется проверить, совпадают ли две переменные</span>. Если одна пере- менная не определена (undefined), а вашей собственной переменной вы вручную присвоили значение undefined,
           переменные будут считаться равными. Но вы же хотите знать, действительно ли значения равны, а не только то, что они не определе- ны. Так, кличка чьего-то домашнего животного и фамилия хозяина могут считаться равными, тогда как на самом деле они являются просто пустыми значениями.</p>
<h3 id="null">null</h3>
<p>null — это специальное значение, указывающее на то, что переменная пуста или имеет неизвестное значение. Данное значение чувствительно к регистру — для написания null используются только строчные буквы:
</p>
<code>let empty = null;</code>
<p>
  Чтобы решить проблему, с которой мы столкнулись при объявлении переменной как неопределенной, следует установить для нее значение null — и проблем не воз- никнет. Это одна из причин, по которой лучше присваивать переменной значение null, если вы хотите указать, что она изначально пуста и неизвестна:</p>
  <code>
    let terribleThingToDo = undefined; <br>
let lastName;<br>
console.log("Same undefined:", lastName === terribleThingToDo);<br>
let betterOption = null;<br>
console.log("Same null:", lastName === betterOption);<br>
Результат будет следующим:<br>
 Same undefined: true<br>
 Same null: false<br>
  </code>
  <p>Как видим, автоматически не определенная переменная, lastName, и намеренно не определенная переменная, terribleThingToDo, считаются равными — это про- блематично. С другой стороны, lastName и betterOption, которой было присвоено значение null, не равны.</p>
		</section>
		<section class="main-section" id="Analysis">
      <header class="title">Анализ и модификация типов данных</header>
      <p>Мы рассмотрели примитивные типы данных. Существует несколько встроенных методов JavaScript, которые помогут справиться с распространенными проблемами, возникающими при работе с примитивами. Встроенные методы — это части логи- ческой схемы, которые можно использовать сразу и не мучиться над их созданием вручную.</p>
<h3>Определение типа переменной</h3>
<p>Иногда трудно определить тип данных, с которым вы имеете дело, особенно в слу- чае null и undefined. Рассмотрим оператор typeof. Он возвращает тип переменной. С его помощью вы можете получить эту информацию. Введите typeof, затем либо пробел, за которым следует рассматриваемая переменная, либо эту переменную в скобках:</p>
<code>testVariable = 1;<br>
  variableTypeTest1 = typeof testVariable;<br>
  variableTypeTest2 = typeof(testVariable);<br>
  console.log(variableTypeTest1);<br>
  console.log(variableTypeTest2);<br>
</code>
<p>Как вы могли предположить, оба метода выведут number. Скобки не требуются, потому что технически typeof является оператором, а не методом, в отличие от console.log. Хотя на практике вы наверняка заметите, что использование скобок облегчает чтение вашего кода. Рассмотрим следующий пример:</p>
<code>
  let str = "Hello"; <br>
let nr = 7;<br>
let bigNr = 12345678901234n;<br>
let bool = true;<br>
let sym = Symbol("unique");<br>
let undef = undefined;<br>
let unknown = null;<br>
console.log("str", typeof str); str string<br>
console.log("nr", typeof nr); nr number<br>
console.log("bigNr", typeof bigNr); bigNr bigint<br>
console.log("bool", typeof bool); bool boolean<br>
console.log("sym", typeof sym); sym symbol<br>
console.log("undef", typeof undef); undef undefined<br>
console.log("unknown", typeof unknown); unknown object<br>
</code>
<p>Последний тип — это и есть тип null. 
  В выводе можно наблюдать, что typeof null возвращает значение object,
   в то время как <span class="codeText">на самом деле null является примити- вом, а не объектом</span>. 
   Это ошибка, которая существует в JavaScript с незапамятных времен и которую пока нет возможности исправить из-за проблем с обратной со- вместимостью. Не беспокойтесь о ней: на выполнение программ она не повлияет, но имейте эту ошибку в виду, поскольку в ближайшее время она никуда не денется и может повлиять на адекватную работу приложений.</p>
   <h3>Преобразование типов данных</h3>
   <p>В JavaScript можно изменить тип данных переменных. Иногда JavaScript делает это автоматически.</p>
   <code>
    let nr1 = 2;<br>
let nr2 = "2";<br>
console.log(nr1 * nr2);<br>
   </code>
   <p>Мы попытались умножить переменную типа Number на переменную типа String. 
    JavaScript не выдает ошибку (как сделали бы многие другие языки), 
    а пытается сна- чала преобразовать значение переменной String в Number. Если это можно сделать, команда выполняется без каких-либо проблем, как если бы были объявлены две пере- менные типа Number. В таком случае метод console.log() выдает результат 4 на экране.</p>
    <p>Но это достаточно опасный ход!</p>
    <code>let nr1 = 2;<br>
      let nr2 = "2";<br>
      console.log(nr1 + nr2); // 22 typeof = string<br>
    </code>
    <p>Результатом будет 22. Знак плюс можно использовать для объединения строк.
       Поэтому вместо преобразования string в number код <span class="codeText">преобразует number в string.</span>
        И соединяет две строки — 2 и 2, выдавая в результате строку 22.
         К счастью, нам не нужно полагаться на поведение JavaScript при преобразовании типов данных.
          Существуют встроенные функции, которые мы можем для этого использовать.</p>
<h3>Три метода преобразования: String(), Number() и Boolean()</h3>
<p>
  Рассмотрим три метода преобразования: <span class="codeText">String()</span>, Number() и Boolean().
   Первый преобразует переменную в тип String. Он, в общем-то, <span class="codeText">принимает любое значение, включая undefined и null, и заключает его в кавычки.</span></p>
<p>Второй <span class="codeText">Number()</span> пытается преобразовать переменную в тип Number. Если это невозможно сделать логически, значением переменной станет NaN (not a number — «не число»).</p>
<p><span class="codeText">Boolean()</span> преобразует переменную в тип Boolean. Данный метод <span class="codeText">будет работать для всего, кроме null, undefined, 0 (число), пустой строки и NaN.</span> Посмотрим на эти методы в действии:</p>
<code>
  let nrToStr = 6;<br>
nrToStr = String(nrToStr);<br>
console.log(nrToStr, typeof nrToStr); // 6 string<br>
let strToNr = "12";<br>
strToNr = Number(strToNr);<br>
console.log(strToNr, typeof strToNr); // 12 number<br>
let strToBool = "any string will return true";<br>
strToBool = Boolean(strToBool);<br>
console.log(strToBool, typeof strToBool); // true boolean<br>
</code>
<p>Выглядит довольно просто, но не все так очевидно. Например, вы все еще можете
  получить не то, на что рассчитывали:</p>
  <code>
    let nullToNr = null;<br>
nullToNr = Number(nullToNr);<br>
console.log("null", nullToNr, typeof nullToNr); //  null 0 number<br>
let strToNr = "";<br>
strToNr = Number(strToNr);<br>
console.log("empty string", strToNr, typeof strToNr); // empty string 0 number<br>
  </code>
  <p>Как видим, <span class="codeText">пустая строка и null в итоге дают 0</span>. Это выбор, сделанный создателями JavaScript, о котором вам нужно знать — данная опция может пригодиться в тех случаях, 
    когда вы захотите преобразовать строку в 0, в то время как она пуста или равна нулю.</p>
    <code>
      Далее введем фрагмент:<br>
let strToNr2 = "hello";<br>
strToNr2 = Number(strToNr2);<br>
console.log(strToNr2, typeof strToNr2); // NaN number<br>
    </code>
    <p>Следовательно, все, что нельзя интерпретировать как число, просто удалив кавыч- ки, будет оцениваться как NaN (не число).
    </p>
    <code>Продолжим таким кодом:<br>
      let strToBool2 = "false";<br>
      strToBool2 = Boolean(strToBool2);<br>
      console.log(strToBool2, typeof strToBool2); // true boolean<br>
      let strToBool = "";<br>
      strToBool = Boolean(strToBool);<br>
      console.log(strToBool, typeof strToBool); // false boolean<br>
    </code>
    <p>Этот пример показывает, что практически любая строка возвращает значение true, 
      когда преобразуется в тип Boolean, даже строка со значением false! Только пустая строка, null и undefined отправят логическое значение false.</p>
<code>
  let nr1 = 2;<br>
let nr2 = "2";<br>
console.log(nr1 + Number(nr2)); // 4<br>
</code>
<p>Строка преобразуется в число до выполнения опера- ции «плюс» — соответственно, это математическая операция, а не объединение строк. В следующих разделах данной главы мы рассмотрим операторы более подробно.</p>

    </section>
    <section class="main-section" id="Operators">
      <header class="title">Операторы</header>
      <p>Операторы будут полезны всякий раз, когда мы захотим работать с переменными, изменять их, выполнять над ними вычисления и сравнивать. Они называются операторами, потому что мы используем их, чтобы оперировать переменными.</p>
<h3>Арифметические операторы</h3>
<h3>Сложение</h3>
<p>Этот оператор также может быть очень полезен для объединения строк. Обратите внимание на пробел после Hello — он нужен в конечном результате:</p>
<code>
  let str1 = "Hello ";<br>
  let str2 = "addition";<br>
  let result2 = str1 + str2; // Hello addition<br>
  let nr1 = 12;<br>
let nr2 = 14;<br>
let result1 = nr1 + nr2; // 26<br>
<p>Если мы сложим две разные строки, это объединит их в одну строку.</p>
</code>
<h3>Вычитание</h3>
<p>Вычитание также работает ожидаемым образом. Для этого действия используется оператор -.</p>
<code>
  let nr1 = 20;<br>
let nr2 = 4;<br>
let str1 = "Hi";<br>

let nr3 = 3;<br>
let result1 = nr1 - nr2;<br>
let result2 = str1 - nr3;<br>
console.log(result1, result2); // 16 NaN<br>
</code>
<p>Первый результат — число 16. А второй результат намного более интересен.
  <span class="codeText"> NaN не ошибка: это просто заключение, что результат вычитания числа из строки не является числом</span>. Спасибо, что не падаешь, JavaScript!</p>
<h3>Умножение</h3>
<p>Мы можем умножать два числовых значения с помощью оператора *. В отличие от некоторых других языков в JavaScript данное действие не получится совершить с числом и строкой.</p>
<p>Результатом умножения числового и нечислового значений является NaN:</p>
<code>
  let nr1 = 15;<br>
let nr2 = 10;<br>
let str1 = "Hi";<br>
let nr3 = 3;<br>
let result1 = nr1 * nr2;<br>
let result2 = str1 * nr3;<br>
console.log(result1, result2); // 150 NaN<br>
</code>
<h3>Деление</h3>
<p>Еще один простой оператор — это деление. Мы можем разделить одно число на другое, используя оператор /:</p>
<code>
  let nr1 = 30;<br>
let nr2 = 5;<br>
let result1 = nr1 / nr2;<br>
console.log(result1); // 6<br>
</code>
<h3>Возведение в степень</h3>
<p>Возведение в степень означает возведение определенного базового числа в степень экспоненты, например xy (произносится как «возведение x в степень y»). Это зна- чит, что x будет умножено само на себя y раз. Чтобы возвести число в степень в JavaScript, используем ** для вызова оператора:</p>
<code>
  let nr1 = 2;<br>
let nr2 = 3;<br>
let result1 = nr1 ** nr2;<br>
console.log(result1); // 8<br>
</code>
<p>Результат этой операции равен 2 в степени 3 (2 × 2 × 2), что составляет 8. Чтобы не превращать книгу в урок математики, добавим только, что, используя дробные показатели, с помощью этой же операции мы можем найти корень числа: например, квадратный корень из значения — это то же самое, что возведение его в степень 0,5.</p>
<h3>Оператор деления по модулю %</h3>
<p>Данный оператор обычно требует пояснений. <span class="codeText">Модуль — это операция, определя- ющая остаток после полного деления одного числа на другое. Количество раз, которое одно число может поместиться в другое</span>, здесь не имеет значения — <span class="red">результатом будет остаток</span>. Для вызова оператора используется символ %. Вот несколько примеров:
</p>
<code>
  let nr1 = 10;<br>
let nr2 = 3;<br>
let result1 = nr1 % nr2;<br>
console.log(`${nr1} % ${nr2} = ${result1}`); // 10 % 3 = 1<br>
let nr3 = 8;<br>
let nr4 = 2;<br>
let result2 = nr3 % nr4;<br>
console.log(`${nr3} % ${nr4} = ${result2}`); // 8 % 2 = 0<br>
let nr5 = 15;<br>
let nr6 = 4;<br>
let result3 = nr5 % nr6;<br>
console.log(`${nr5} % ${nr6} = ${result3}`); 15 % 4 = 3<br>
</code>
<p>Первый пример — 10 % 3, где 3 умещается 3 раза в числе 10 с остатком 1. Вто- рой — 8 % 2. Здесь результат 0, потому что 2 повторяется 4 раза в числе 8 и ничего не остается. Последний — 15 % 4, где 4 умещается 3 раза в числе 15, после чего получается остаток 3.</p>
<p>По сути, это те действия, которые вы бы совершили у себя в голове, если бы вас попросили добавить 125 минут к текущему времени. Вероятно, вы бы сделали две вещи: целочисленное деление, чтобы определить, сколько целых часов содержится в 125 минутах, а затем 125 модуль 60 (в терминах JavaScript, 125 % 60), чтобы сде- лать вывод, что вам придется добавить еще 5 минут. Скажем, наше текущее время 09:59. Скорее всего, вы начнете с добавления 2 часов и дойдете до 11:59, а затем добавите 5 минут, выполнив еще одну операцию по модулю с 59 и 5, добавив еще 1 час к общей сумме и оставив 4 минуты: 12:04.
</p>
<h3>Унарные операторы: инкремент и декремент</h3>
<p>Инкремент и декремент. Здесь нам пригодится термин «операнд». Операнд — то, к чему применяется оператор. Если мы пишем x + y, то x и y — это операнды.</p>
<p>Для данных операторов потребуется только один операнд — поэтому они также называются унарными операторами. Если перед нами x++, то эту запись можно представить в виде x = x + 1. То же самое справедливо для оператора декремента: x-- принимает вид x = x – 1:</p>
<code>
let nr1 = 4;<br>
nr1++;<br>
console.log(nr1); // 5<br>
let nr2 = 4;<br>
nr2--;<br>
console.log(nr2); // 3<br>
</code>
<h3>Операторы prefix и postfix</h3>
  <p>Инкремент может располагаться после операнда (x++), в таком случае он будет на- зываться постфиксным унарным оператором. Он также может располагаться до операнда (++x) — префиксный унарный оператор. Однако он выполняет кое-что
    другое.
  </p>
  <p>Сначала отправляется переменная, потом выполняется постфикс и только после этого — операция. В следующем примере nr повышается на 1 после логирования. Поэтому в первый раз переменная логируется без изменений, потому что обнов- ление еще не произошло. Обновление произойдет во второй раз:</p>
<code>
  let nr = 2;<br>
console.log(nr++); // 2<br>
console.log(nr); // 3<br>
</code>
<p>Префикс выполняется перед отправкой переменной, поэтому чаще всего исполь- зуется именно он.
</p>
<code>
  let nr = 2;<br>
console.log(++nr); // 3<br>
</code>
<p></p>
<code>
  let nr1 = 4;<br>
let nr2 = 5;<br>
let nr3 = 2;<br>
console.log(nr1++ + ++nr2 * nr3++); // ( ++nr2 * nr3++) + nr1++ = 16<br>
</code>
<p>Результат будет равен 16. Сначала будет выполнено умножение в соответствии с основным математическим порядком операций. Для умножения используется число 6 (префикс поднял значение 5 до умножения) и 2 (постфикс поднял значение 2 только после выполнения операции, а значит, на текущие вычисления это не повлияло). Получается 12. У переменной nr1 постфиксный оператор, поэтому он будет исполнен после операции сложения. Таким образом, результатом сложения 12 и 4 будет 16.
</p>
<h3>Сочетание операторов</h3>
<p>
  Можно создавать сочетания операторов, и работать они будут так же, как и в ма- тематике. Они будут исполняться точно в том же порядке, и совершенно не обя- зательно слева направо. Это происходит благодаря явлению, называемому прио­ ритетом оператора.
</p>
<p>Есть еще одна деталь, которую следует принять во внимание, — группировка. Вы можете группировать операторы с помощью ( и ). Операции, заключенные в круглые скобки, имеют наивысший приоритет. После этого порядок операций определяется в зависимости от их типа (сначала с наивысшим приоритетом). Если операции имеют одинаковый приоритет, они выполняются слева направо.</p>
<p></p>
<table>
  <thead>
      <tr>
          <th>Название</th>
          <th>Символ</th>
          <th>Пример</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Группирование</td>
          <td>(...)</td>
          <td>(x + y)</td>
      </tr>
      <tr>
          <td>Возведение в степень</td>
          <td>**</td>
          <td>x ** y</td>
      </tr>
  </tbody>
  <tfoot>
      <tr>
          <td>Префиксы инкремент и декремент</td>
          <td>--, ++</td>
          <td>--x, ++y</td> 
      </tr>
  </tfoot>
  <tfoot>
    <tr>
        <td>Умножение, деление, модуляция</td>
        <td>*, /, %</td>
        <td>x * y, x / y, x % y</td> 
    </tr>
</tfoot>
<tfoot>
  <tr>
      <td>Сложение и вычитание</td>
      <td>+, -</td>
      <td>x + y, x - y</td>
  </tr>
</tfoot>
</table>
<div class="practicalWrapper">
  <h3 class="practical">Практическое занятие 2.3</h3>
<p>Напишите фрагмент кода для вычисления гипотенузы треугольника с ис- пользованием теоремы Пифагора при заданных значениях двух других сторон. Теорема гласит, что отношение между сторонами прямоугольного треугольника выражается так: a2 + b2 = c2.</p>
<p class="center">Теорема Пифагора применима только к прямоугольным треуголь- никам. Стороны, соединенные под углом 90 градусов, называются катетами (в формуле обозначены как a и b). Самая длинная сто- рона, не прилегающая к прямому углу, называется гипотенузой, обозначена буквой c.</p>
<p>Чтобы получить значение для a и b, можно использовать prompt(). Напишите код, который будет запрашивать от пользователя длину катетов a и b. Затем возведите значения a и b в квадрат. После сложите результаты и извлеките квадратный корень. Полученное значение выведите на экран.</p>
<button>решение</button>
</div>
<h3>Операторы присваивания</h3>
<p>
  Мы уже видели один назначающий оператор, когда присваивали значения пере- менным. Для операции присваивания чаще всего используется знак =. Но есть несколько других способов. Каждый двоичный арифметический оператор имеет соответствующий оператор присваивания — так можно сделать написанный код короче. Например,x += 5 означает x = x+5, а x** = 3 означает x = x**3 (x в степени 3).</p>
  <p>В этом примере мы объявим переменную x и зададим ей начальное значение 2:</p>
  <code>
    let x = 2;<br>
x += 2;<br>
  </code>
  <p>После операции присваивания значение x стало 4, потому что x += 2 — это то же самое, что x = x + 2.</p>
  <p>В следующей операции присваивания мы вычтем 2:</p>
  <code>
    x -= 2;<br>
  </code>
  <p>После этой операции x снова примет значение 2 (x = x – 2). Далее мы умножим значение на 6:
  </p>
  <code>
x *= 6;<br>
  </code>
  <p>Когда эта строка кода будет исполнена, значение x с 2 изменится на 12 (x = x * 6). В следующей строке мы используем оператор присваивания, чтобы продемонстри- ровать деление:</p>
  <code>
    x /= 3;<br>
  </code>
  <p>После деления x на 3 получим значение 4. Далее мы используем оператор присва-
    ивания для возведения в степень:
    </p>
    <code>
      x **= 2;<br>
    </code>
    <p>Значение x теперь равно 16, потому что предыдущее значение 4, возведенное в сте- пень 2, равняется 16 (4 × 4). Последний оператор присваивания продемонстрирует модуляцию:
    </p>
    <code>
      x %= 3;<br>
    </code>
    <p>После выполнения этого оператора значение x стало равно 1, потому что 3 поме-
      щается 5 раз в числе 16 и остается 1.</p>
      <div class="practicalWrapper">
        <h3 class="practical">Практическое занятие 2.4</h3>
        <p>Создайте три численные переменные: a, b и c. Обновите эти переменные с помощью следующих действий, используя операторы присваивания:
        </p>
        <ul>
          <li>сложите b и a;</li>
          <li>разделите a на c;</li>
          <li>замените значение модуляцией c и b;</li>
          <li>выведите все три числа на экран.</li>
        </ul>
      </div>
      <h3>Операторы сравнения</h3>
      <p>Сравнительные операторы отличаются от тех, которые мы уже рассмотрели. Результат их действия всегда принимает значение типа Boolean: true или false.</p>
      <h4>Равно</h4>
      <p>Существует несколько операторов равенства, которые определяют, равны ли два значения. Они бывают двух видов: только равное значение или равные значение и тип данных. Первый возвращает значение true, когда значения равны, даже если тип отличается, в то время как второй возвращает значение true только тогда, когда значение и тип данных совпадают:</p>
      <code>
        let x = 5;<br>
let y = "5";<br>
console.log(x == y); // true<br>
console.log(x === y); // false<br>
      </code>
      <p> == Оператор double equals (двойной знак равно) означает, что сравниваться будут толь- ко значения, но не типы данных. Если обе переменные имеют значение 5, в консоли выводится true. Такой тип равенства обычно <span class="codeText"> == называют свободным равенством.</span></p>
<p>=== Оператор triple equals (три знака равно) означает, что он будет оценивать как значение, так и тип данных, чтобы определить, равны ли обе переменные или нет. Чтобы этот оператор отправил значение true, они должны быть тождественно равны, но в нашем случае это не так, поэтому оператор вернет значение false:</p>
<p>Также данный оператор <span class="codeText"> === называется строгим равенством</span>. Тройное равенство ис- пользуется в большинстве случаев, когда нужно проверить равенство, так как только с его помощью вы можете быть уверены, что обе переменные действительно равны.</p>
<h3>Не равно !=</h3>
<p>Не равно очень похоже на равно, только оно делает все наоборот — возвращает true, когда две переменные не равны, и false, когда равны. Для обозначения этого оператора используется восклицательный знак перед знаком равно:</p>
<code>let x = 5; <br>
  let y = "5"; <br>
  console.log(x != y); // false<br>
</code>
<p>
  Этот код вернет в консоль значение false. Если вам интересно, как все работает,
   взгляните еще раз на операторы double и triple equals: 
   у операторов неравнознач- ности принцип действия аналогичный.
    <span class="codeText">Когда в операторе есть только один знак равенства, он не проводит строгое сравнение и возвращает результат false</span>,
     если приходит к выводу, что переменные равны. <span class="codeText">Оператор, у которого два знака равенства, 
      проверяет строгое несоответствие</span>:</p>
  <code>console.log(x !== y); // true</code>
  <p>Пока у x и y типы данных разные, операнды не равны, поэтому выводится значе-
    ние true.</p>
    <h3>Больше и меньше</h3>
    <p><span class="codeText">Оператор «больше» возвращает значение true, если левая часть уравнения больше правой</span>. Для обозначения этого оператора используется знак >. Есть также 
      <span class="codeText">оператор «больше либо равно», >=, который возвращает true, если левая часть больше или равна правой части</span>.</p>
    <code>let x = 5;<br>
      let y = 6;<br>
      console.log(y > x); // true<br>
    </code>
    <p>В консоли будет зафиксировано значение true, потому что y больше, чем x.</p>
    <code>
      console.log(x > y) // false;
    </code>
    <p>Пока значение x будет меньше, чем значение y, это выражение будет возвращать значение false.</p>
    <code>
      console.log(y > y) // false;
    </code>
    <p>Значение y не больше y, поэтому результатом будет false.</p>
    <code>
      console.log(y >= y); // true
    </code>
    <p>Этот оператор проверяет, будет ли y больше или равен y; пока это условие соблю- дается, значение будет true.</p>
    <p>Логично, что есть также операторы «меньше» (<) и «меньше либо равно» (<=). Они очень похожи на предыдущие.</p>
    <code>console.log(y < x); // false</code>
    <p>Первый оператор будет выдавать результат false, пока y больше x.</p>
    <code>console.log(x < y); // true</code>
    <p>Второй выдает true, потому что x меньше y.</p>
    <code>console.log(y < y); // false</code>
    <p>Значение y не меньше y, поэтому результатом будет false.</p>
    <code>console.log(y <= y); //true</code>
    <p>Этот оператор проверяет, будет ли y меньше или равен y. Переменные y равны, поэтому результатом будет true.</p>
    </section>
    <section class="main-section" id="LogicalOperators">
      <header class="title">Логические операторы</header>
      <p>
        Логические операторы используются всякий раз, когда нужно проверить два усло- вия в одном или отменить условие. Можно использовать «И», «ИЛИ» и «НЕ».</p>
        <h3 id="and">«И» (&&)</h3>
        <p>Рассмотрим первый оператор «И». Если вы хотите проверить, что x действительно больше y и y больше z, вы должны суметь объединить эти два выражения. Это мож- но реализовать с помощью оператора &&. 
          <span class="codeText">Он вернет значение true, только если оба выражения правдивы:</span></p>
        <code>
          let x = 1;<br>
let y = 2;<br>
let z = 3;<br>
        </code>
        <p>Используя эти переменные, мы рассмотрим логические операторы:</p>
        <code>
          console.log(x < y && y < z); // true
        </code>
        <p>
          Это выражение выдаст значение true. 
          <span class="codeText">Его можно расшифровать как «если x меньше y и y меньше z, результат будет true»</span>. Выражение верно, поэтому мы и получим true. Следующий пример выдаст результат false:
        </p>
        <code>
          console.log(x > y && y < z); // false
        </code>
        <p>Поскольку значение x не превышает y, одна часть выражения не соответствует
          действительности, это приведет к значению false.</p>
          <h3 id="or">«ИЛИ» (||)</h3>
          <p>Если вы хотите получить значение true, даже если всего одно из выражений ис- тинно, стоит использовать «ИЛИ». Оператор «ИЛИ» выглядит так — ||. Данные прямые линии используются для проверки того, является ли одно из двух пред- ставленных выражений истинным — в таком случае все выражение оценивается как true. Рассмотрим оператор «ИЛИ» в действии:</p>
          <code>
            console.log(x > y || y < z);
          </code>
          <p>Выражение приведет к результату true, в то время как при использовании && оно принимало значение false. Это связано с тем, что только одна из двух частей долж- на быть истинной, чтобы все выражение оценивалось как true. В данном случае y действительно меньше z.</p>
          <p>Если обе части выражения неверны, то будет возвращено значение false, как в следующем случае:</p>
          <code>console.log(x > y || y > z);</code>
          <h3 id="not">«НЕ» (!)</h3>
          <p>В некоторых случаях вам потребуется отрицать логическую переменную. Это действие изменит текущее значение на противоположное. Отрицание можно реа- лизовать с помощью восклицательного знака, который означает «не»:</p>
          <code>
            let x = false;<br>
console.log(!x);<br>
          </code>
          <p>
            Результат в консоли будет регистрироваться как true, поскольку оператор просто изменит логическое значение на противоположное. Вы также можете отрицать выражение, которое вычисляется как логическое значение, но вам при- дется сначала его сгруппировать, дабы убедиться, что оно вычисляется в первую очередь.</p>
            <code>
              let x = 1;<br>
let y = 2;<br>
console.log(!(x < y));<br>
            </code>
            <p>Значение x меньше значения y, поэтому выражение считается true. Но оно от- рицается восклицательным знаком — поэтому на экран будет выведен резуль- тат false.</p>
            <h3>Вопросы для самопроверки</h3>
          <ol>
            <li>К какому типу данных относится следующая переменная?
              <code>const c = "5";</code>
            </li>
            <li>Какой тип данных представляет переменная ниже?
              <code>const c = 91;</code>
            </li>
            <li>Какая из строк обычно считается лучшей, строка 1 или строка 2?
              <code>let empty1 = undefined; //строка 1 <br>
                let empty2 = null; //строка 2</code>
            </li>
            <li>Какой результат после выполнения следующего кода будет выведен на экран?
              <code>
                let a = "Hello";<br>
   a = "world";<br>
   console.log(a);<br>
              </code>
            </li>
            <li>Какой результат выводится в консоли?
              <code>
                let a = "world";<br>
   let b = `Hello ${a}!`;<br>
   console.log(b);<br>
              </code>
            </li>
            <li>Каково значение a?
              <code>
                let a = "Hello";<br>
   a = prompt("world");<br>
   console.log(a);<br>
              </code>
            </li>
            <li>
              Какое значение b будет выведено на экран?
              <code>
                let a = 5;<br>
   let b = 70;<br>
   let c = "5";<br>
   b++;<br>
   console.log(b);<br>
              </code>
            </li>
            <li>Каково значение result?
              <code>
                let result = 3 + 4 * 2 / 8;
              </code>
            </li>
            <li>
              Каковы значения total и total2?
              <code>
                let firstNum = 5;<br>
                let secondNum = 10;<br>
                firstNum++;<br>
                secondNum--;<br>
let total = ++firstNum + secondNum;<br>
console.log(total);<br>
let total2 = 500 + 100 / 5 + total--;<br>
console.log(total2);<br>
              </code>
            </li>
            <li>Какой результат вы увидите на экране?
              <code>
                const a = 5;<br>
const b = 10;<br>
console.log(a > 0 && b > 0);<br>
console.log(a == 5 && b == 4);<br>
console.log(true || false);<br>
console.log(a == 3 || b == 10);<br>
console.log(a == 3 || b == 7);<br>
              </code>
            </li>
          </ol>
    </section>
    <section class="main-section" id="Array">
			<header class="title">Массивы и их свойства</header>
      <p>
        Массивы — это перечни значений. Значения могут быть всех типов, один массив может содержать значения разных типов. Зачастую очень удобно хранить множе- ство значений в одной переменной, например список студентов или продуктов, результаты теста. Как только вы начнете писать скрипты, вам придется очень часто создавать массивы. Скажем, когда вы захотите отслеживать все вводимые данные или когда понадобится список опций для представления пользователю.
      </p>
<h3>Создание массивов</h3>
<p>Как считаете, какая из следующих записей лучшая?</p>
<code>
  arr1 = new Array("purple", "green", "yellow");<br>
arr2 = ["black", "orange", "pink"];<br>
</code>
<p>
  Если вы выбрали второй вариант, с использованием квадратных скобок, — вы пра- вы. Это самый читаемый способ записи для создания массива. С другой стороны, первый вариант может дать неожиданные результаты. Взгляните на обе строки кода. Как думаете, каким будет итог?
</p>
<code>
  arr3 = new Array(10);<br>
arr4 = [10];<br>
</code>
<p>
  Вероятно, вы чувствуете, что здесь что-то не так. Массив с одним значением 10 получится не во всех вариантах. Нужный результат даст только вторая запись, arr4. Первый вариант даст массив с десятью неопределенными значениями. Если логировать значения следующим образом:
</p>
<code>
  console.log(arr3); // [ <10 empty items> ] <br>
console.log(arr4); // [ 10 ]
</code>
<p>
  Спасибо, JavaScript! Это было крайне полезно. Делаем вывод: если только вашей целью не является получение массива с неопределенными значениями, исполь- зуйте квадратные скобки!
</p>
<p>
  Как вы помните, у нас могут быть смешанные массивы, ведь массивы позволяют хранить переменные любого типа. Значения массива не будут преобразованы в один тип данных или что-то в этом роде. JavaScript просто хранит все переменные с их собственным типом данных и значением в массиве:
</p>
<code>
  let arr = ["hi there", 5, true];<br>
console.log(typeof arr[0]); // string <br>
console.log(typeof arr[1]); // number <br>
console.log(typeof arr[2]); // boolean
</code>
<p>
  Еще одна интересная штука о массивах, которую мы здесь рассмотрим, — это результат определения массива с помощью const. Вы можете изменить значения констант массива, но не можете изменить сам массив. Фрагмент кода для демон- страции:
</p>
<code>
  const arr = ["hi there"];<br>
arr[0] = "new value";<br>
console.log(arr[0]); // new value<br>
arr = ["nope, now you are overwriting the array"]; // TypeError: Assignment to constant variable.
</code>
<h3>Доступ к элементам</h3>
<p>
  Прекрасный массив, который мы только что создали, стал бы намного мощнее, если бы мы могли получить доступ к его элементам. Мы можем сделать это, обра- тившись к индексу массива. Мы его сами не указывали, но нам это и не было нуж- но. JavaScript присваивает индекс каждому значению в массиве данных. Первое значение имеет индекс 0, второе — 1, третье — 2 и т. д. Если необходимо вызвать определенное значение по его положению в массиве, можно указать имя массива, добавить квадратные скобки в конце и вписать в них индекс, к которому мы хотим получить доступ. Например:
</p>
<code>
  cars = ["Toyota", "Renault", "Volkswagen"];<br>
console.log(cars[0]); // Toyota<br>
</code>
<p>
  Этот оператор зафиксирует значение Toyota и выведет его на экран, потому что мы вызвали позицию 0 в массиве. В ней содержится первое значение списка.
</p>
<code>
  console.log(cars[1]); // Renault
</code>
<p>
  Вызов позиции с индексом 1 вернет нам значение второго элемента массива —
Renault. Это и будет выведено на экран.
</p>
<code>console.log(cars[2]); // Volkswagen</code>
<p>
  Третьему элементу присвоен индекс 2, поэтому будет выведено его следующее значение — Volkswagen. Как думаете, что произойдет, если мы используем отрица- тельное значение индекса или значение индекса, которое превышает количество существующих значений?
</p>
<code>
  console.log(cars[3]);<br>
console.log(cars[-1]);<br>
</code>
      </section>


    <section class="main-section" id="Projects">
      <header class="title">Проекты</header>
      <h3 class="practical">Проекты главы 2</h3>
      <h3>Конвертер миль в километры</h3>
      <p>Создайте переменную, содержащую значение в милях, преобразуйте ее в километры и запишите значение в километрах в следующем формате:</p>
      <code>
        Расстояние 130 миль. равно 209,2142 км
      </code>
      <h3>Вычислитель индекса массы тела (ИМТ)</h3>
      <p>Установите значения для роста в дюймах и веса в фунтах, затем преобразуйте значения в сантиметры и килограммы:</p>
      <ul>
        <li>1 дюйм равен 2,54 см;</li>
        <li>2,2046 фунта равны 1 кг.</li>
      </ul>
      <p>Выведите результаты. Затем рассчитайте и запишите ИМТ: он равен весу (в кило- граммах), деленному на квадрат роста (в метрах). Выведите результаты на экран.</p>
      
    </section>
    <div class="void" id="bottom"></div>
    <!-- <section class="main-section" id="Mathematics">
      <header class="title">Математика</header>
      <h3>Квадратный корень</h3>
      <p>Квадратный корень — это математическая операция, обратная возведению числа в квадрат. Если x x — это квадратный корень из a a, то x 2 = a x 2 =a. Обозначается это как x = a x= a.</p>
    </section> -->
	</main>
</div>
<script src="script.js"></script>
<script src="./nav.js"></script>
</body>
</html>