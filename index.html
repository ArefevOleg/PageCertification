<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="stylesheet" href="style.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
	<title>JS Documentation</title>
</head>
<body class="body">
<div class="container">
	<nav id="navbar">
		<header class="navTitle title"><span class="accent">JS</span> Documentation</header>
		<ul class="listItem">
			<li class="item"><a href="#Browser" class="nav-link">Работа в браузере</a></li>
			<li class="item"><a href="#Variables" class="nav-link">Переменные</a></li>
			<li class="item"><a href="#Primitives" class="nav-link">Примитивные типы данных</a></li>
			<li class="item"><a href="#Analysis" class="nav-link">Анализ и модификация типов данных</a></li>
			<li class="item"><a href="#Variables" class="nav-link">Variables</a></li>
			<li class="item"><a href="#Declaring_variables" class="nav-link">Declaring variables</a></li>
			<li class="item"><a href="#Variable_scope" class="nav-link">Variable scope</a></li>
			<li class="item"><a href="#Global_variables" class="nav-link">Global variables</a></li>
			<li class="item"><a href="#Constants" class="nav-link">Constants</a></li>
			<li class="item"><a href="#Data_types" class="nav-link">Data types</a></li>
			<li class="item"><a href="#if...else_statement" class="nav-link">if...else statement</a></li>
			<li class="item"><a href="#while_statement" class="nav-link">while statement</a></li>
			<li class="item"><a href="#Function_declarations" class="nav-link">Function declarations</a></li>
			<li class="item"><a href="#Reference" class="nav-link">Reference</a></li>
		</ul>
	</nav>
	<main id="main-doc" class="main">
		<section class="main-section" id="Browser">
			<header class="title">JavaScript работа в браузере</header>
			<p>JavaScript является интерпретируемым языком программирования: это значит,
         компьютер распознает его в процессе работы кода.
          Некоторые языки перед за- пуском кода требуют обработки 
          (данный процесс называется компиляцией) — но для JavaScript в этом нет необходимости. 
          Компьютер интерпретирует JavaScript на лету. При этом «движок», понимающий JavaScript, 
          называется интерпрета- тором.
        </p>
		</section>
		<section class="main-section" id="Variables">
			<header class="title">Переменные</header>
			<p>
				Определение переменной состоит из трех частей: определяющего слова <b class="codeText">let, var</b> или <b class="codeText">const</b>, 
        названия и значения.
        <b class="codeText"> let и var</b> используются для переменных, 
        которым где-то в программе может быть присвоено новое значение.
         Различия между let и var не так просты. Они связаны с областью их применения.
			</p>
			<ul>
				<li><b class="codeText">var</b>относится к глобальным переменным
          <p>Глобальность var означает, что вы можете использовать переменную, ранее опреде- ленную как var, в любом месте кода.</p>
				</li>
				<li>
					<b class="codeText">let</b> — локальная переменная
          <p> Область действия let ограничивается только конкретным блоком кода: вы можете использовать переменные, определенные с помо- щью let, только там, где они и были определены. </p>
				</li>
				<li>
					<b class="codeText">const</b>относится к глобальным переменным
          <p>
            Оператор const используется для переменных, которым присваивается значение только один раз,
             например π, которое априори не меняется. Если вы попытаетесь переназначить переменную const,
              система выдаст сообщение об ошибке</p>
              <code>
                const someConstant = 3;<br>
                someConstant = 4;</code>
                <code>Uncaught TypeError: Assignment to constant variable.</code>
				</li>
			</ul>
		</section>
		<section class="main-section" id="Primitives">
			<header class="title">Примитивы</header>
      <h3>String</h3>
			<p>
				Строковый тип данных используется для передачи текстовых значений. Это последовательность символов. Есть несколько способов объявить переменную строкового типа:
        <ul>
          <li>двойные кавычки;</li>
          <li>одинарные кавычки;</li>
          <li>обратные апострофы: специальные шаблонные строки, в которых вы можете напрямую использовать переменные.</li>
        </ul>
        <p>Так, например, следующее написание приведет к ошибке, потому что строка будет за- канчиваться апострофом внутри слова let's:</p>
        <code>let funActivity = 'Let's learn JavaScript';</code>
			</p>
      <p>Слово Let будет определено как строка, но после него набор символов не будет ин- терпретирован. Но если вы объявите строку, заключив ее в двойные кавычки, стро- ка не завершится, когда достигнет апострофа, потому что программа будет искать другую двойную кавычку. Следовательно, эта альтернатива будет работать лучше:</p>
      <code>let funActivity = "Let's learn JavaScript";</code>
      <p>Аналогичная история с двойными кавычками. Следующий код не будет работать:</p>
      <code>let question = "Do you want to learn JavaScript? "Yes!"";</code>
			<p>
				В строке, использующей обратные апострофы, вы можете ссылаться на перемен- ные — значение переменной будет подставлено в строку. Как во фрагменте кода, представленном ниже:
			</p>
      <code>let language = "JavaScript";<br>
        let message = `Let's learn ${language}`;<br>
        console.log(message);
        </code>
        <h3>Escape-символы</h3>
        <p>Допустим, мы хотим использовать в нашей строке двойные кавычки, одинарные кавычки и обратные апострофы. С теми ингредиентами, которые у нас есть сейчас, сделать подобное невозможно. Но для этой проблемы есть элегантное решение — специальный символ, с помощью которого можно сказать JavaScript: «Не читай следующий символ как обычно». Речь об escape-символе, обратном слеше.</p>
        <p>Обратный слеш может использоваться для того, чтобы интерпретатор не видел одинарные или двойные кавычки и не заканчивал строку слишком рано:</p>
        <code>
          let str = "Hello, what's your name? Is it \"Mike\"?";<br>
          console.log(str);<br>
          let str2 = 'Hello, what\'s your name? Is it "Mike"?';<br>
          console.log(str2);<br>
          В консоли выводится: <br>
 Hello, what's your name? Is it "Mike"?<br>
 Hello, what's your name? Is it "Mike"?<br>
          </code>
          <p>У escape-символа есть много назначений. Вы можете использовать его для созда- ния разрыва строки с помощью \n или для включения символа обратного слеша в текст с помощью \\:</p>
          <code>let str3 = "New \nline."; // перенос на новую строку<br> 
            let str4 = "I'm containing a backslash: \\!";<br>
            console.log(str3);<br>
            console.log(str4);<br>
            </code>
            <h3>Number</h3>
            <p>Во многих языках существует очень четкая разница между различными типами чисел. Разработчики JavaScript решили использовать один тип данных для них всех: Number (если точнее, это 64-битное число с плавающей точкой). Этот тип может хранить довольно большие числа (как со знаком, так и без), десятичные дроби и многое другое.</p>
            <p>Существуют различные виды чисел, которые он может представлять. Прежде всего, целые числа, например 4 или 89. Но тип данных Number также может использовать- ся для представления десятичных, экспоненциальных, восьмеричных, шестнадца- теричных и двоичных чисел. Следующий пример кода говорит сам за себя:</p>
            <code>let intNr = 1;<br>
              let decNr = 1.5;<br>
              let expNr = 1.4e15;<br>
let octNr = 0o10; //в десятичной системе будет 8 <br>
let hexNr = 0x3E8; //в десятичной системе будет 1000 <br>
let binNr = 0b101; //в десятичной системе будет 5 <br>
            </code>
            <p>Не стоит переживать насчет последних трех позиций, если вы с ними не зна- комы, это просто разные способы представления чисел, с которыми вы можете столкнуться в более продвинутых задачах информационных технологий. Главное здесь то, что все вышеперечисленные числа относятся к типу данных Number. Итак, целые числа — это числа, подобные этим:</p>
            <code>
              let intNr2 = 3434;<br>
let intNr3 = -111;<br>
Числа с плавающей точкой тоже относятся к типу Number: <br>
let decNr2 = 45.78;<br>
И двоичные числа: <br>
let binNr2 = 0b100; // десятичная версия будет 4 <br>
            </code>
            <h3>BigInt</h3>
            <p>Диапазон значений типа данных Number находится между 253–1 и –(253–1). BigInt вступает в дело, когда вам требуются числа больше (или меньше) этого интервала. Тип данных BigInt можно узнать по окончанию n:</p>
            <code>let bigNr = 90071992547409920n;</code>
            <p>Рассмотрим, что происходит, когда мы начинаем вычисления между ранее задан- ным целым числом типа Number, intNr, и значением типа BigInt, bigNr:</p>
            <code>let result = bigNr + intNr; <br>
              Результат будет таким: <br>
              Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions
            </code>
            <p>Ошибка типов данных — TypeError! Совершенно ясно: что-то пошло не так. Для выполнения операций нельзя смешивать тип данных BigInt с типом данных Number. Это то, что следует запомнить на будущее, когда вы будете работать с BigInt, — вы можете использовать BigInt только с другими BigInt.</p>
            <h3>Boolean</h3>
            <p>Логический тип данных Boolean может принимать два значения: true (истина) и false (ложь). И ничего больше. Этот тип данных часто используется в коде, особенно в логических выражениях:</p>
            <code>
              let bool1 = false; <br>
              let bool2 = true;
            </code>
            <h3>Symbol</h3>
            <p>Символьный тип Symbol совершенно новый и представлен в ES6 (мы упоминали стандарт ECMAScript 6 в главе 1 «Начало работы с JavaScript»). Он может уста- навливаться в случаях, когда важно подчеркнуть, что переменные не равны, даже если их значение и тип одинаковы (в этом случае они обе примут тип символа). Сравните следующие объявления строк с объявлениями символов (и те и другие имеют одинаковое значение):</p>
            <code>
              let str1 = "JavaScript is fun!";<br>
let str2 = "JavaScript is fun!";<br>
console.log("These two strings are the same:", str1 === str2);<br>
let sym1 = Symbol("JavaScript is fun!");<br>
let sym2 = Symbol("JavaScript is fun!");<br>
console.log("These two Symbols are the same:", sym1 === sym2);<br>
Результат будет следующим:<br>
 These two strings are the same: true<br>
 These two Symbols are the same: false<br>
            </code>
            <p>В первой части кода JavaScript приходит к выводу, что строки одинаковые, 
              у них один тип и значение. Однако во второй части кода каждый символ определяется как уникальный. Поэтому,
               хотя содержимое символов одинаковое, они не совпадают и при сравнении выводится значение false.
                <span class="codeText">Эти символьные типы данных могут быть очень удобны в качестве свойств объектов</span>, которые мы рассмотрим в <span class="codeText">главе 3</span>.</p>
        <h3>undefined</h3>
        <code>
          let unassigned; <br>
console.log(unassigned); <br>
Результат будет таким: Undefined
        </code>
        <p>Мы также можем целенаправленно назначать undefined — важно знать, что такое возможно. Но еще важнее знать, что <span class="codeText">присвоение типа undefined вручную — плохая практика:</span></p>
        <p>Да, так можно, но лучше так не делайте. По целому ряду причин — например,<span class="codeText"> в слу- чаях, когда требуется проверить, совпадают ли две переменные</span>. Если одна пере- менная не определена (undefined), а вашей собственной переменной вы вручную присвоили значение undefined,
           переменные будут считаться равными. Но вы же хотите знать, действительно ли значения равны, а не только то, что они не определе- ны. Так, кличка чьего-то домашнего животного и фамилия хозяина могут считаться равными, тогда как на самом деле они являются просто пустыми значениями.</p>
<h3>null</h3>
<p>null — это специальное значение, указывающее на то, что переменная пуста или имеет неизвестное значение. Данное значение чувствительно к регистру — для написания null используются только строчные буквы:
</p>
<code>let empty = null;</code>
<p>
  Чтобы решить проблему, с которой мы столкнулись при объявлении переменной как неопределенной, следует установить для нее значение null — и проблем не воз- никнет. Это одна из причин, по которой лучше присваивать переменной значение null, если вы хотите указать, что она изначально пуста и неизвестна:</p>
  <code>
    let terribleThingToDo = undefined; <br>
let lastName;<br>
console.log("Same undefined:", lastName === terribleThingToDo);<br>
let betterOption = null;<br>
console.log("Same null:", lastName === betterOption);<br>
Результат будет следующим:<br>
 Same undefined: true<br>
 Same null: false<br>
  </code>
  <p>Как видим, автоматически не определенная переменная, lastName, и намеренно не определенная переменная, terribleThingToDo, считаются равными — это про- блематично. С другой стороны, lastName и betterOption, которой было присвоено значение null, не равны.</p>
		</section>
		<section class="main-section" id="Analysis">
      <header class="title">Анализ и модификация типов данных</header>
      <p>Мы рассмотрели примитивные типы данных. Существует несколько встроенных методов JavaScript, которые помогут справиться с распространенными проблемами, возникающими при работе с примитивами. Встроенные методы — это части логи- ческой схемы, которые можно использовать сразу и не мучиться над их созданием вручную.</p>
<h3>Определение типа переменной</h3>
<p>Иногда трудно определить тип данных, с которым вы имеете дело, особенно в слу- чае null и undefined. Рассмотрим оператор typeof. Он возвращает тип переменной. С его помощью вы можете получить эту информацию. Введите typeof, затем либо пробел, за которым следует рассматриваемая переменная, либо эту переменную в скобках:</p>
<code>testVariable = 1;<br>
  variableTypeTest1 = typeof testVariable;<br>
  variableTypeTest2 = typeof(testVariable);<br>
  console.log(variableTypeTest1);<br>
  console.log(variableTypeTest2);<br>
</code>
<p>Как вы могли предположить, оба метода выведут number. Скобки не требуются, потому что технически typeof является оператором, а не методом, в отличие от console.log. Хотя на практике вы наверняка заметите, что использование скобок облегчает чтение вашего кода. Рассмотрим следующий пример:</p>
<code>
  let str = "Hello"; <br>
let nr = 7;<br>
let bigNr = 12345678901234n;<br>
let bool = true;<br>
let sym = Symbol("unique");<br>
let undef = undefined;<br>
let unknown = null;<br>
console.log("str", typeof str); str string<br>
console.log("nr", typeof nr); nr number<br>
console.log("bigNr", typeof bigNr); bigNr bigint<br>
console.log("bool", typeof bool); bool boolean<br>
console.log("sym", typeof sym); sym symbol<br>
console.log("undef", typeof undef); undef undefined<br>
console.log("unknown", typeof unknown); unknown object<br>
</code>
<p>Последний тип — это и есть тип null. 
  В выводе можно наблюдать, что typeof null возвращает значение object,
   в то время как <span class="codeText">на самом деле null является примити- вом, а не объектом</span>. 
   Это ошибка, которая существует в JavaScript с незапамятных времен и которую пока нет возможности исправить из-за проблем с обратной со- вместимостью. Не беспокойтесь о ней: на выполнение программ она не повлияет, но имейте эту ошибку в виду, поскольку в ближайшее время она никуда не денется и может повлиять на адекватную работу приложений.</p>
   <h3>Преобразование типов данных</h3>
   <p>В JavaScript можно изменить тип данных переменных. Иногда JavaScript делает это автоматически.</p>
   <code>
    let nr1 = 2;<br>
let nr2 = "2";<br>
console.log(nr1 * nr2);<br>
   </code>
   <p>Мы попытались умножить переменную типа Number на переменную типа String. 
    JavaScript не выдает ошибку (как сделали бы многие другие языки), 
    а пытается сна- чала преобразовать значение переменной String в Number. Если это можно сделать, команда выполняется без каких-либо проблем, как если бы были объявлены две пере- менные типа Number. В таком случае метод console.log() выдает результат 4 на экране.</p>
    <p>Но это достаточно опасный ход!</p>
    <code>let nr1 = 2;<br>
      let nr2 = "2";<br>
      console.log(nr1 + nr2); // 22 typeof = string<br>
    </code>
    <p>Результатом будет 22. Знак плюс можно использовать для объединения строк.
       Поэтому вместо преобразования string в number код <span class="codeText">преобразует number в string.</span>
        И соединяет две строки — 2 и 2, выдавая в результате строку 22.
         К счастью, нам не нужно полагаться на поведение JavaScript при преобразовании типов данных.
          Существуют встроенные функции, которые мы можем для этого использовать.</p>
<h3>Три метода преобразования: String(), Number() и Boolean()</h3>
<p>
  Рассмотрим три метода преобразования: <span class="codeText">String()</span>, Number() и Boolean().
   Первый преобразует переменную в тип String. Он, в общем-то, <span class="codeText">принимает любое значение, включая undefined и null, и заключает его в кавычки.</span></p>

    </section>
	</main>
</div>
<script src="script.js"></script>
</body>
</html>